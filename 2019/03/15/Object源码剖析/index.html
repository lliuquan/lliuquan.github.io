<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  
  <title>Object源码剖析（顺带分析了notify/wait） | Whits&#39;s Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="本文主要讲解了 JDK 下的Object的部分源码，以及涉及到的wait和notify的一些相关知识点，例如：对象锁与锁池和等待池，如何正确使用wait和notify，以及延伸出来的生产者与消费者问题，最后还有一些参考代码，本文参考资料见文末">
<meta property="og:type" content="article">
<meta property="og:title" content="Object源码剖析（顺带分析了notify&#x2F;wait）">
<meta property="og:url" content="http://yoursite.com/2019/03/15/Object源码剖析/index.html">
<meta property="og:site_name" content="Whits&#39;s Blog">
<meta property="og:description" content="本文主要讲解了 JDK 下的Object的部分源码，以及涉及到的wait和notify的一些相关知识点，例如：对象锁与锁池和等待池，如何正确使用wait和notify，以及延伸出来的生产者与消费者问题，最后还有一些参考代码，本文参考资料见文末">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="d:/BackupHexo/source/img/Object/waitPool.png">
<meta property="og:image" content="d:/BackupHexo/source/img/Object/waitPool2.png">
<meta property="og:image" content="d:/BackupHexo/source/img/Object/mark1.png">
<meta property="og:image" content="d:/BackupHexo/source/img/Object/mark2.png">
<meta property="og:updated_time" content="2019-05-07T12:33:05.624Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Object源码剖析（顺带分析了notify&#x2F;wait）">
<meta name="twitter:description" content="本文主要讲解了 JDK 下的Object的部分源码，以及涉及到的wait和notify的一些相关知识点，例如：对象锁与锁池和等待池，如何正确使用wait和notify，以及延伸出来的生产者与消费者问题，最后还有一些参考代码，本文参考资料见文末">
<meta name="twitter:image" content="d:/BackupHexo/source/img/Object/waitPool.png">
  
    <link rel="alternative" href="/atom.xml" title="Whits&#39;s Blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/img/favicon.png">
  
  
      <link rel="stylesheet" href="//cdn.bootcss.com/animate.css/3.5.0/animate.min.css">
  
  <link rel="stylesheet" href="/css/style.css">
  <link rel="stylesheet" href="/font-awesome/css/font-awesome.min.css">
  <link rel="apple-touch-icon" href="/apple-touch-icon.png">
  
  
      <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  
  <!-- 加载特效 -->
    <script src="/js/pace.js"></script>
    <link href="/css/pace/pace-theme-flash.css" rel="stylesheet">
  <script>
      var yiliaConfig = {
          rootUrl: '/',
          fancybox: true,
          animate: true,
          isHome: false,
          isPost: true,
          isArchive: false,
          isTag: false,
          isCategory: false,
          open_in_new: false
      }
  </script>
</head></html>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
    <header id="header" class="inner">
        <a href="/" class="profilepic">
            
            <img lazy-src="/img/head.jpg" class="js-avatar">
            
        </a>

        <hgroup>
          <h1 class="header-author"><a href="/" title="Hi Mate">Whits</a></h1>
        </hgroup>

        
        <p class="header-subtitle">just do it</p>
        
        
        
            <div id="switch-btn" class="switch-btn">
                <div class="icon">
                    <div class="icon-ctn">
                        <div class="icon-wrap icon-house" data-idx="0">
                            <div class="birdhouse"></div>
                            <div class="birdhouse_holes"></div>
                        </div>
                        <div class="icon-wrap icon-ribbon hide" data-idx="1">
                            <div class="ribbon"></div>
                        </div>
                        
                        <div class="icon-wrap icon-link hide" data-idx="2">
                            <div class="loopback_l"></div>
                            <div class="loopback_r"></div>
                        </div>
                        
                        
                        <div class="icon-wrap icon-me hide" data-idx="3">
                            <div class="user"></div>
                            <div class="shoulder"></div>
                        </div>
                        
                    </div>
                    
                </div>
                <div class="tips-box hide">
                    <div class="tips-arrow"></div>
                    <ul class="tips-inner">
                        <li>菜单</li>
                        <li>标签</li>
                        
                        <li>友情链接</li>
                        
                        
                        <li>关于我</li>
                        
                    </ul>
                </div>
            </div>
        

        <div id="switch-area" class="switch-area">
            <div class="switch-wrap">
                <section class="switch-part switch-part1">
                    <nav class="header-menu">
                        <ul>
                        
                            <li><a href="/Home">博客首页</a></li>
                        
                            <li><a href="/works">作品展示</a></li>
                        
                            <li><a href="/about">留言打卡</a></li>
                        
                            <li><a href="/FrontEndGuide">前端导航</a></li>
                        
                        </ul>
                    </nav>
                    <nav class="header-nav">
                        <ul class="social">
                            
                                <a class="fl mail" target="_blank" href="mailto:780101896@qq.com" title="mail">mail</a>
                            
                                <a class="fl github" target="_blank" href="https://github.com/lliuquan" title="github">github</a>
                            
                                <a class="fl zhihu" target="_blank" href="https://www.zhihu.com/people/liu-quan-7-71/activities" title="zhihu">zhihu</a>
                            
                        </ul>
                    </nav>
                </section>
                
                
                <section class="switch-part switch-part2">
                    <div class="widget tagcloud" id="js-tagcloud">
                        
                    </div>
                </section>
                
                
                
                <section class="switch-part switch-part3">
                    <div id="js-friends">
                    
                      <a target="_blank" class="main-nav-link switch-friends-link" href="/V">0</a>
                    
                      <a target="_blank" class="main-nav-link switch-friends-link" href="/2">1</a>
                    
                      <a target="_blank" class="main-nav-link switch-friends-link" href="/E">2</a>
                    
                      <a target="_blank" class="main-nav-link switch-friends-link" href="/X">3</a>
                    
                      <a target="_blank" class="main-nav-link switch-friends-link" href="/：">4</a>
                    
                      <a target="_blank" class="main-nav-link switch-friends-link" href="/h">5</a>
                    
                      <a target="_blank" class="main-nav-link switch-friends-link" href="/t">6</a>
                    
                      <a target="_blank" class="main-nav-link switch-friends-link" href="/t">7</a>
                    
                      <a target="_blank" class="main-nav-link switch-friends-link" href="/p">8</a>
                    
                      <a target="_blank" class="main-nav-link switch-friends-link" href="/s">9</a>
                    
                      <a target="_blank" class="main-nav-link switch-friends-link" href="/:">10</a>
                    
                      <a target="_blank" class="main-nav-link switch-friends-link" href="/">11</a>
                    
                      <a target="_blank" class="main-nav-link switch-friends-link" href="/">12</a>
                    
                      <a target="_blank" class="main-nav-link switch-friends-link" href="/w">13</a>
                    
                      <a target="_blank" class="main-nav-link switch-friends-link" href="/w">14</a>
                    
                      <a target="_blank" class="main-nav-link switch-friends-link" href="/w">15</a>
                    
                      <a target="_blank" class="main-nav-link switch-friends-link" href="/.">16</a>
                    
                      <a target="_blank" class="main-nav-link switch-friends-link" href="/v">17</a>
                    
                      <a target="_blank" class="main-nav-link switch-friends-link" href="/2">18</a>
                    
                      <a target="_blank" class="main-nav-link switch-friends-link" href="/e">19</a>
                    
                      <a target="_blank" class="main-nav-link switch-friends-link" href="/x">20</a>
                    
                      <a target="_blank" class="main-nav-link switch-friends-link" href="/.">21</a>
                    
                      <a target="_blank" class="main-nav-link switch-friends-link" href="/c">22</a>
                    
                      <a target="_blank" class="main-nav-link switch-friends-link" href="/o">23</a>
                    
                      <a target="_blank" class="main-nav-link switch-friends-link" href="/m">24</a>
                    
                      <a target="_blank" class="main-nav-link switch-friends-link" href="/">25</a>
                    
                      <a target="_blank" class="main-nav-link switch-friends-link" href="/ ">26</a>
                    
                      <a target="_blank" class="main-nav-link switch-friends-link" href="/S">27</a>
                    
                      <a target="_blank" class="main-nav-link switch-friends-link" href="/e">28</a>
                    
                      <a target="_blank" class="main-nav-link switch-friends-link" href="/g">29</a>
                    
                      <a target="_blank" class="main-nav-link switch-friends-link" href="/m">30</a>
                    
                      <a target="_blank" class="main-nav-link switch-friends-link" href="/e">31</a>
                    
                      <a target="_blank" class="main-nav-link switch-friends-link" href="/n">32</a>
                    
                      <a target="_blank" class="main-nav-link switch-friends-link" href="/t">33</a>
                    
                      <a target="_blank" class="main-nav-link switch-friends-link" href="/f">34</a>
                    
                      <a target="_blank" class="main-nav-link switch-friends-link" href="/a">35</a>
                    
                      <a target="_blank" class="main-nav-link switch-friends-link" href="/u">36</a>
                    
                      <a target="_blank" class="main-nav-link switch-friends-link" href="/l">37</a>
                    
                      <a target="_blank" class="main-nav-link switch-friends-link" href="/t">38</a>
                    
                      <a target="_blank" class="main-nav-link switch-friends-link" href="/：">39</a>
                    
                      <a target="_blank" class="main-nav-link switch-friends-link" href="/h">40</a>
                    
                      <a target="_blank" class="main-nav-link switch-friends-link" href="/t">41</a>
                    
                      <a target="_blank" class="main-nav-link switch-friends-link" href="/t">42</a>
                    
                      <a target="_blank" class="main-nav-link switch-friends-link" href="/p">43</a>
                    
                      <a target="_blank" class="main-nav-link switch-friends-link" href="/s">44</a>
                    
                      <a target="_blank" class="main-nav-link switch-friends-link" href="/:">45</a>
                    
                      <a target="_blank" class="main-nav-link switch-friends-link" href="/">46</a>
                    
                      <a target="_blank" class="main-nav-link switch-friends-link" href="/">47</a>
                    
                      <a target="_blank" class="main-nav-link switch-friends-link" href="/s">48</a>
                    
                      <a target="_blank" class="main-nav-link switch-friends-link" href="/e">49</a>
                    
                      <a target="_blank" class="main-nav-link switch-friends-link" href="/g">50</a>
                    
                      <a target="_blank" class="main-nav-link switch-friends-link" href="/m">51</a>
                    
                      <a target="_blank" class="main-nav-link switch-friends-link" href="/e">52</a>
                    
                      <a target="_blank" class="main-nav-link switch-friends-link" href="/n">53</a>
                    
                      <a target="_blank" class="main-nav-link switch-friends-link" href="/t">54</a>
                    
                      <a target="_blank" class="main-nav-link switch-friends-link" href="/f">55</a>
                    
                      <a target="_blank" class="main-nav-link switch-friends-link" href="/a">56</a>
                    
                      <a target="_blank" class="main-nav-link switch-friends-link" href="/u">57</a>
                    
                      <a target="_blank" class="main-nav-link switch-friends-link" href="/l">58</a>
                    
                      <a target="_blank" class="main-nav-link switch-friends-link" href="/t">59</a>
                    
                      <a target="_blank" class="main-nav-link switch-friends-link" href="/.">60</a>
                    
                      <a target="_blank" class="main-nav-link switch-friends-link" href="/c">61</a>
                    
                      <a target="_blank" class="main-nav-link switch-friends-link" href="/o">62</a>
                    
                      <a target="_blank" class="main-nav-link switch-friends-link" href="/m">63</a>
                    
                      <a target="_blank" class="main-nav-link switch-friends-link" href="/">64</a>
                    
                      <a target="_blank" class="main-nav-link switch-friends-link" href="/ ">65</a>
                    
                      <a target="_blank" class="main-nav-link switch-friends-link" href="/S">66</a>
                    
                      <a target="_blank" class="main-nav-link switch-friends-link" href="/t">67</a>
                    
                      <a target="_blank" class="main-nav-link switch-friends-link" href="/a">68</a>
                    
                      <a target="_blank" class="main-nav-link switch-friends-link" href="/c">69</a>
                    
                      <a target="_blank" class="main-nav-link switch-friends-link" href="/k">70</a>
                    
                      <a target="_blank" class="main-nav-link switch-friends-link" href="/o">71</a>
                    
                      <a target="_blank" class="main-nav-link switch-friends-link" href="/v">72</a>
                    
                      <a target="_blank" class="main-nav-link switch-friends-link" href="/e">73</a>
                    
                      <a target="_blank" class="main-nav-link switch-friends-link" href="/r">74</a>
                    
                      <a target="_blank" class="main-nav-link switch-friends-link" href="/f">75</a>
                    
                      <a target="_blank" class="main-nav-link switch-friends-link" href="/l">76</a>
                    
                      <a target="_blank" class="main-nav-link switch-friends-link" href="/o">77</a>
                    
                      <a target="_blank" class="main-nav-link switch-friends-link" href="/w">78</a>
                    
                      <a target="_blank" class="main-nav-link switch-friends-link" href="/：">79</a>
                    
                      <a target="_blank" class="main-nav-link switch-friends-link" href="/ ">80</a>
                    
                      <a target="_blank" class="main-nav-link switch-friends-link" href="/h">81</a>
                    
                      <a target="_blank" class="main-nav-link switch-friends-link" href="/t">82</a>
                    
                      <a target="_blank" class="main-nav-link switch-friends-link" href="/t">83</a>
                    
                      <a target="_blank" class="main-nav-link switch-friends-link" href="/p">84</a>
                    
                      <a target="_blank" class="main-nav-link switch-friends-link" href="/s">85</a>
                    
                      <a target="_blank" class="main-nav-link switch-friends-link" href="/:">86</a>
                    
                      <a target="_blank" class="main-nav-link switch-friends-link" href="/">87</a>
                    
                      <a target="_blank" class="main-nav-link switch-friends-link" href="/">88</a>
                    
                      <a target="_blank" class="main-nav-link switch-friends-link" href="/s">89</a>
                    
                      <a target="_blank" class="main-nav-link switch-friends-link" href="/t">90</a>
                    
                      <a target="_blank" class="main-nav-link switch-friends-link" href="/a">91</a>
                    
                      <a target="_blank" class="main-nav-link switch-friends-link" href="/c">92</a>
                    
                      <a target="_blank" class="main-nav-link switch-friends-link" href="/k">93</a>
                    
                      <a target="_blank" class="main-nav-link switch-friends-link" href="/o">94</a>
                    
                      <a target="_blank" class="main-nav-link switch-friends-link" href="/v">95</a>
                    
                      <a target="_blank" class="main-nav-link switch-friends-link" href="/e">96</a>
                    
                      <a target="_blank" class="main-nav-link switch-friends-link" href="/r">97</a>
                    
                      <a target="_blank" class="main-nav-link switch-friends-link" href="/f">98</a>
                    
                      <a target="_blank" class="main-nav-link switch-friends-link" href="/l">99</a>
                    
                      <a target="_blank" class="main-nav-link switch-friends-link" href="/o">100</a>
                    
                      <a target="_blank" class="main-nav-link switch-friends-link" href="/w">101</a>
                    
                      <a target="_blank" class="main-nav-link switch-friends-link" href="/.">102</a>
                    
                      <a target="_blank" class="main-nav-link switch-friends-link" href="/c">103</a>
                    
                      <a target="_blank" class="main-nav-link switch-friends-link" href="/o">104</a>
                    
                      <a target="_blank" class="main-nav-link switch-friends-link" href="/m">105</a>
                    
                      <a target="_blank" class="main-nav-link switch-friends-link" href="/">106</a>
                    
                      <a target="_blank" class="main-nav-link switch-friends-link" href="/ ">107</a>
                    
                      <a target="_blank" class="main-nav-link switch-friends-link" href="/H">108</a>
                    
                      <a target="_blank" class="main-nav-link switch-friends-link" href="/o">109</a>
                    
                      <a target="_blank" class="main-nav-link switch-friends-link" href="/l">110</a>
                    
                      <a target="_blank" class="main-nav-link switch-friends-link" href="/l">111</a>
                    
                      <a target="_blank" class="main-nav-link switch-friends-link" href="/i">112</a>
                    
                      <a target="_blank" class="main-nav-link switch-friends-link" href="/s">113</a>
                    
                      <a target="_blank" class="main-nav-link switch-friends-link" href="/：">114</a>
                    
                      <a target="_blank" class="main-nav-link switch-friends-link" href="/h">115</a>
                    
                      <a target="_blank" class="main-nav-link switch-friends-link" href="/t">116</a>
                    
                      <a target="_blank" class="main-nav-link switch-friends-link" href="/t">117</a>
                    
                      <a target="_blank" class="main-nav-link switch-friends-link" href="/p">118</a>
                    
                      <a target="_blank" class="main-nav-link switch-friends-link" href="/s">119</a>
                    
                      <a target="_blank" class="main-nav-link switch-friends-link" href="/:">120</a>
                    
                      <a target="_blank" class="main-nav-link switch-friends-link" href="/">121</a>
                    
                      <a target="_blank" class="main-nav-link switch-friends-link" href="/">122</a>
                    
                      <a target="_blank" class="main-nav-link switch-friends-link" href="/w">123</a>
                    
                      <a target="_blank" class="main-nav-link switch-friends-link" href="/w">124</a>
                    
                      <a target="_blank" class="main-nav-link switch-friends-link" href="/w">125</a>
                    
                      <a target="_blank" class="main-nav-link switch-friends-link" href="/.">126</a>
                    
                      <a target="_blank" class="main-nav-link switch-friends-link" href="/h">127</a>
                    
                      <a target="_blank" class="main-nav-link switch-friends-link" href="/o">128</a>
                    
                      <a target="_blank" class="main-nav-link switch-friends-link" href="/l">129</a>
                    
                      <a target="_blank" class="main-nav-link switch-friends-link" href="/l">130</a>
                    
                      <a target="_blank" class="main-nav-link switch-friends-link" href="/i">131</a>
                    
                      <a target="_blank" class="main-nav-link switch-friends-link" href="/s">132</a>
                    
                      <a target="_blank" class="main-nav-link switch-friends-link" href="/c">133</a>
                    
                      <a target="_blank" class="main-nav-link switch-friends-link" href="/h">134</a>
                    
                      <a target="_blank" class="main-nav-link switch-friends-link" href="/u">135</a>
                    
                      <a target="_blank" class="main-nav-link switch-friends-link" href="/a">136</a>
                    
                      <a target="_blank" class="main-nav-link switch-friends-link" href="/n">137</a>
                    
                      <a target="_blank" class="main-nav-link switch-friends-link" href="/g">138</a>
                    
                      <a target="_blank" class="main-nav-link switch-friends-link" href="/.">139</a>
                    
                      <a target="_blank" class="main-nav-link switch-friends-link" href="/c">140</a>
                    
                      <a target="_blank" class="main-nav-link switch-friends-link" href="/o">141</a>
                    
                      <a target="_blank" class="main-nav-link switch-friends-link" href="/m">142</a>
                    
                      <a target="_blank" class="main-nav-link switch-friends-link" href="/">143</a>
                    
                    </div>
                </section>
                

                
                
                <section class="switch-part switch-part4">
                
                    <div id="js-aboutme">NBA、半个历史爱好者、编程学习者、运动爱好者、在校学生</div>
                </section>
                
            </div>
        </div>
    </header>                
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
      <div class="overlay">
          <div class="slider-trigger"></div>
          <h1 class="header-author js-mobile-header hide"><a href="/" title="Me">Whits</a></h1>
      </div>
    <div class="intrude-less">
        <header id="header" class="inner">
            <a href="/" class="profilepic">
                
                    <img lazy-src="/img/head.jpg" class="js-avatar">
                
            </a>
            <hgroup>
              <h1 class="header-author"><a href="/" title="Me">Whits</a></h1>
            </hgroup>
            
            <p class="header-subtitle">just do it</p>
            
            <nav class="header-menu">
                <ul>
                
                    <li><a href="/Home">博客首页</a></li>
                
                    <li><a href="/works">作品展示</a></li>
                
                    <li><a href="/about">留言打卡</a></li>
                
                    <li><a href="/FrontEndGuide">前端导航</a></li>
                
                <div class="clearfix"></div>
                </ul>
            </nav>
            <nav class="header-nav">
                <div class="social">
                    
                        <a class="mail" target="_blank" href="mailto:780101896@qq.com" title="mail">mail</a>
                    
                        <a class="github" target="_blank" href="https://github.com/lliuquan" title="github">github</a>
                    
                        <a class="zhihu" target="_blank" href="https://www.zhihu.com/people/liu-quan-7-71/activities" title="zhihu">zhihu</a>
                    
                </div>
            </nav>
        </header>                
    </div>
</nav>
      <div class="body-wrap"><article id="post-Object源码剖析" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2019/03/15/Object源码剖析/" class="article-date">
      <time datetime="2019-03-15T00:00:00.000Z" itemprop="datePublished">2019-03-15</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      Object源码剖析（顺带分析了notify/wait）
    </h1>
  

      </header>
      
      <div class="article-info article-info-post">
        

        
        <div class="clearfix"></div>
      </div>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <excerpt in index | 首页摘要> 

<p>本文主要讲解了 JDK 下的Object的部分源码，以及涉及到的wait和notify的一些相关知识点，例如：<strong>对象锁与锁池和等待池</strong>，<strong>如何正确使用wait和notify</strong>，以及延伸出来的<strong>生产者与消费者问题</strong>，最后还有一些<strong>参考代码</strong>，本文参考资料见文末</p>
<a id="more"></a>
<the rest of contents | 余下全文>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> java.lang;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Object</span> </span>&#123;   <span class="comment">//所有的类都继承了Object,所有对象，包括数组都实现了这个类的方法</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">registerNatives</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        registerNatives();      <span class="comment">//静态代码块，初始化时调用，调用本地方法</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> Class&lt;?&gt; getClass();</span><br><span class="line">    <span class="comment">//返回这个Object运行时的对象</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//返回这个对象的哈希值，默认返回该对象在内存中的地址，重写该方法可以提高hashmap的性能</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">this</span> == obj);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//对象比较方法，默认比较对象的地址是否相等，重写equals一般也会重写hashcode</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">native</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException</span>;</span><br><span class="line">    <span class="comment">//对象克隆方法，有深克隆和浅克隆之分,支持复制的类必须要实现Cloneable接口,否则产生异常</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getClass().getName() + <span class="string">"@"</span> + Integer.toHexString(hashCode());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//toString方法，返回当前类的名字+@+默认hashcode方法16进制的值，重写可提高类的可读性</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">notify</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//对象唤醒方法，唤醒在对象监视器等待的单个线程，调用该方法后本线程进入对象锁定池，准备获取对象锁，进入运行状态</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">notifyAll</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//全部对象唤醒方法，唤醒在对象监视器等待的全部线程，具体唤醒哪个由操作系统决定</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">wait</span><span class="params">(<span class="keyword">long</span> timeout)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line">    <span class="comment">//线程等待方法，timeout表示要等待的最长时间(以毫秒为单位)，调用该方法后，线程会放弃对象锁，进入等待此对象的等待锁定池</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">wait</span><span class="params">(<span class="keyword">long</span> timeout, <span class="keyword">int</span> nanos)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">//加上超值时间，但是也难以达到，实际上是直接+1</span></span><br><span class="line">        <span class="keyword">if</span> (timeout &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"timeout value is negative"</span>);</span><br><span class="line">            <span class="comment">//等待的时间小于0，为负值抛出异常(以毫秒为单位)</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (nanos &lt; <span class="number">0</span> || nanos &gt; <span class="number">999999</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"nanosecond timeout value out of range"</span>);</span><br><span class="line">            <span class="comment">//等待时间小于0或者额外时间大于999999(以毫秒为单位)</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (nanos &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            timeout++;  <span class="comment">//等待时间，毫秒+1</span></span><br><span class="line">        &#125;</span><br><span class="line">        wait(timeout);</span><br><span class="line">        <span class="comment">//调用wait(timeout)方法</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">wait</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        wait(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//对象等待方法，等待时间为0，直接进入等待池里面</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123; &#125;</span><br><span class="line">    <span class="comment">//不应该继续使用的方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="一-等待-唤醒机制的常见用法"><a href="#一-等待-唤醒机制的常见用法" class="headerlink" title="一. 等待/唤醒机制的常见用法"></a>一. 等待/唤醒机制的常见用法</h4><p>Java多线程开发中，我们常用到wait()和notify()方法来实现线程间的协作，简单的说步骤如下： </p>
<ol>
<li><p>A线程取得锁，执行wait()，释放锁; </p>
</li>
<li><p>B线程取得锁，完成业务后执行notify()，再释放锁; </p>
</li>
<li><p>B线程释放锁之后，A线程取得锁，继续执行wait()之后的代码；<strong>（请参考下面的代码一，线程相互通信）</strong></p>
</li>
</ol>
<h4 id="二-Object里面的wait与notify方法"><a href="#二-Object里面的wait与notify方法" class="headerlink" title="二. Object里面的wait与notify方法"></a>二. Object里面的wait与notify方法</h4><hr>
<h5 id="1-监视器，对象锁，锁池与等待池"><a href="#1-监视器，对象锁，锁池与等待池" class="headerlink" title="(1).监视器，对象锁，锁池与等待池"></a>(1).监视器，对象锁，锁池与等待池</h5><p><strong>Java 虚拟机上运行的每个对象来说都一个内置的监视器（Monitor）,Monitor里面又有一个内置的对象锁和两个池，锁(monitor)池和等待(wait)池(等待队列)</strong>，而这两个池又与 Object 基类的 wait、notify、notifyAll 三个方法和 同步代码块 相关。</p>
<p><img src="D:\BackupHexo\source\img\Object\waitPool.png" alt></p>
<p><strong>锁池的本质</strong></p>
<p>就是假设线程 A 已经拥有了某个对象（不是类）的锁，而其它线程 B、C 想要调用这个对象的某个 synchronized 方法（或者块），由于这些 B、C 线程在进入对象的 synchronized 方法（或者块）之前必须先获得该对象锁的拥有权，而恰巧该对象的锁目前正被线程 A 所拥有，所以<strong>这些 B、C 线程也在抢夺对象锁，但是没有抢成功，就进入了该对象的锁池，这就是锁池，也是之前存在的疑问之一，请见文末。</strong></p>
<p><strong>等待池的本质</strong></p>
<p>就是假设线程 A 调用了某个对象的 wait() 方法，线程 A 就会释放该对象的锁（因为 wait() 方法必须在 synchronized中使用，所以执行 wait() 方法前线程 A 已经持有了该对象的锁)，同时线程 A 就进入到了该对象的等待池中。</p>
<p>如果此时线程 B 调用了相同对象的 notifyAll() 方法，则处于该对象等待池中的线程就会全部进入该对象的锁池中去准备争夺一个锁的拥有权，没有获取到锁而已经呆在锁池的线程只能继续等待其他机会获取锁，而<strong>不能再主动回到等待池（除非该线程调用wait方法）</strong>。而如果此时线程 B 调用的是相同对象的 notify() 方法，则仅仅会有一个处于该对象等待池中的线程<strong>（随机，具体唤醒哪一个，由cpu调度决定）</strong>进入该对象的锁池中去准备争夺锁的拥有权（notify进入锁池之后是否还需要竞争？？？，目前是还没解决的疑问之一）。</p>
<p><strong>请花点时间认真阅读下图（理解每一步执行顺序）</strong></p>
<p><img src="D:\BackupHexo\source\img\Object\waitPool2.png" alt></p>
<hr>
<h5 id="2-注意事项"><a href="#2-注意事项" class="headerlink" title="(2).注意事项"></a>(2).注意事项</h5><ul>
<li><p>当一个线程A调用了某个对象的 wait() 方法后就必须等其他线程B或者C调用这个对象的 notify/notifyall 方法<strong>(意味着必须是调用同一个对象的wait和notify方法，但不是要同一个线程调用，因为调用wait的线程已经进入等待池里面了)</strong></p>
</li>
<li><p><strong>notify方法只有一个线程在等待的时候它才有用武之地，但是还是不推荐使用notify,因为会容易造成死锁和不想关的线程的意外或者恶意的等待—来自Effective Java。请参考下面的代码二（notify发生死锁）</strong></p>
</li>
<li><p><strong>wait与notify方法只能用在synchroized 同步代码块或者同步方法，并且在当前对象的同步块中。</strong>如果在 A 对象的方法中调用 B 对象的 wait 或者 notify 方法，虚拟机会抛出 IllegalMonitorStateException，非法的监视器异常，因为你这个线程持有的监视器和你调用的监视器的不是一个对象，非法监视器异常的情况还有以下这些，还有实现中断和虚假唤醒是可能的，<strong>请参考下面的代码三（虚假唤醒）</strong></p>
<ul>
<li>如果调用 wait()时，没有持有适当的锁，则抛出 IllegalMonitorStateException</li>
<li>如果调用 notify()时，没有持有适当的锁，也会抛出 IllegalMonitorStateException</li>
</ul>
</li>
<li><p><strong>优先级高的线程竞争到对象锁的概率大</strong>，假若某线程没有竞争到该对象锁，它还会留在锁池中，唯有线程再次调用 wait()方法，它才会重新回到等待池中。而竞争到对象锁的线程则继续往下执行，直到执行完了 synchronized 代码块，它会释放掉该对象锁，这时锁池中的线程会继续竞争该对象锁。</p>
</li>
<li><strong>多线程由于synchronized抢占对象锁，被阻塞，进入Blocked状态，放入基于锁的等待队列（锁池），并不是在等待池中，也是疑问中的第三点。</strong></li>
</ul>
<h5 id="3-工作流程"><a href="#3-工作流程" class="headerlink" title="(3).工作流程"></a>(3).工作流程</h5><ol>
<li><p><strong>wait的工作流程：</strong>调用任何对象的wait()方法会让当前线程进入等待池，并且用来释放对象锁</p>
</li>
<li><p><strong>notify的工作流程：</strong>对象调用notify方法，用来通知那些可能等待该对象的对象锁的其他线程（<strong>就是在等待池里面的线程们）</strong>。</p>
<p>如果调用notify时，有多个线程等待，<strong>则线程规划器任意从等待池挑选出其中一个的线程来发出通知，并使它等待获取该对象的对象锁（调用notify 后,当前线程不会马上释放该对象锁，此时内定的线程并不能马上获取该对象锁，要等到程序退出 synchronized 代码块后，当前线程才会释放锁，内定的线程才可以获取该对象锁）</strong>，但不惊动其他同样在等待池的线程们。</p>
<p>当第一个获得了该对象锁的线程运行完毕以后，它会释放掉该对象锁，<strong>此时如果该对象没有再次使用 notify 语句，则即便该对象已经空闲，其他在锁池等待的线程由于没有得到该对象的通知，会继续阻塞在锁池，直到这个对象发出一个 notify 或 notifyAll</strong>。</p>
<p>这里需要注意：<strong>它们等待的是被 notify 或 notifyAll，而不是等待对象锁，等待对象锁应该时在notify或notifyAll方法之后。</strong>如果时调用了notify方法，则等待锁的过程应该是内定了对象锁的线程之后，等待调用wait方法之后或者说退出同步代码块之后。如果调用了notifyAll()方法执行后的情况不同，请看下面的notifyAll工作流程。</p>
</li>
<li><p><strong>notifyAll 的工作流程：</strong>notifyAll 使所有原来在该对象上的等待池的线程统统退出等待池（即全部被唤醒，不再等待 notify 或 notifyAll，但由于此时还没有获取到该对象锁，因此还不能继续往下执行），变成等待获取该对象上的锁，一旦该对象锁被释放（调用了 wait方法或者退出synchronized 代码块的时候）他们就会去竞争。</p>
<p>如果其中一个线程获得了该对象锁，它就会继续往下执行，在它退出 synchronized 代码块，释放锁后，其他的已经被唤醒的线程将会继续竞争获取该锁，一直进行下去，直到所有被唤醒的线程都执行完毕。</p>
<p><strong>言简意赅的小结：</strong></p>
<p>notify()和notifyAll()都是Object对象用于通知处在等待该对象的线程的方法。两者的最大区别在于：</p>
<p>notifyAll使在该对象上所有wait状态的线程变成等待该对象上的锁，一旦该对象被解锁，他们就会去竞争。</p>
<p>notify则文明得多，他只是选择一个wait状态线程进行通知，并使它变成等待该对象上的锁，一旦该对象被解锁，它自己去执行。</p>
<p>即便该对象已经空闲，其他wait状态等待的线程由于没有得到该对象的通知，继续处在wait状态，直到这个对象再次发出一个notify或notifyAll。</p>
<p><code>notify()</code>方法只会唤起一个线程， 且无法指定唤醒哪一个线程，所以只有在多个执行相同任务的线程在并发运行时， 我们不关心哪一个线程被唤醒时，才会使用<code>notify()</code></p>
<p><strong>必须从同步环境内调用wait()、notify()、notifyAll()方法，而且必须是先wait，后notify。线程不能调用对象上等待或通知的方法，除非它拥有那个对象的锁。</strong></p>
</li>
</ol>
<h5 id="4-什么时候释放对象锁？"><a href="#4-什么时候释放对象锁？" class="headerlink" title="(4).什么时候释放对象锁？"></a>(4).什么时候释放对象锁？</h5><p>由于等待一个锁定线程只有在获得这把锁之后，才能恢复运行，所以让持有锁的线程在不需要锁的时候及时释放锁是很重要的。在以下情况下，持有锁的线程会释放锁：</p>
<ol>
<li>执行完同步代码块。</li>
<li>在执行同步代码块的过程中，遇到异常而导致线程终止。</li>
<li>在执行同步代码块的过程中，执行了锁所属对象的wait()方法，这个线程会释放锁，进行对象的等待池。<br><strong>除了以上情况外，只要持有锁的此案吃还没有执行完同步代码块，就不会释放锁。因此在以下情况下，线程不会释放锁</strong></li>
<li>在执行同步代码块的过程中，执行了Thread.sleep()方法，当前线程放弃CPU，开始睡眠，在睡眠中不会释放锁。</li>
<li>在执行同步代码块的过程中，执行了Thread.yield()方法，当前线程放弃CPU，但不会释放锁。</li>
<li>在执行同步代码块的过程中，其他线程执行了当前对象的suspend()方法，当前线程被暂停，但不会释放锁。但Thread类的suspend()方法已经被废弃。</li>
</ol>
<h5 id="5-在synchronized中才能使用wait与notify方法"><a href="#5-在synchronized中才能使用wait与notify方法" class="headerlink" title="(5).在synchronized中才能使用wait与notify方法?"></a>(5).在synchronized中才能使用wait与notify方法?</h5><p>假设有2个线程，分别是生产者和消费者，他们有各自的任务。</p>
<p>1.1生产者检查条件（如缓存满了）-&gt; 1.2生产者必须等待<br>2.1消费者消费了一个单位的缓存 -&gt; 2.2重新设置了条件（如缓存没满） -&gt; 2.3调用notifyAll()唤醒生产者</p>
<p>我们希望的顺序是： 1.1-&gt;1.2-&gt;2.1-&gt;2.2-&gt;2.3<br>但是由于CPU执行是随机的，可能会导致 2.3 先执行，1.2 后执行，这样就会导致生产者永远也醒不过来了！</p>
<p><strong>所以我们必须对流程进行管理，也就是同步，通过在同步块中并结合 wait 和 notify 方法，我们可以手动对线程的执行顺序进行调整。</strong></p>
<p><code>synchronized</code> 的含义：</p>
<ul>
<li>Java中每一个对象都可以成为一个监视器（<code>Monitor</code>）, 该Monitor由一个锁（lock）, 一个等待队列（waiting queue ）, 一个入口队列( entry queue).</li>
<li>对于一个对象的方法， 如果没有<code>synchronized</code>关键字， 该方法可以被任意数量的线程，在任意时刻调用。</li>
<li>对于添加了<code>synchronized</code>关键字的方法，任意时刻只能被<strong>唯一的一个</strong>获得了<strong>对象实例锁</strong>的线程调用。</li>
<li><code>synchronized</code>用于实现多线程的同步操作</li>
</ul>
<p><code>wait()</code>功用</p>
<ul>
<li><p><code>wait()</code>, <code>notify()</code>, <code>notifyAll()</code> 和 <code>synchonized</code> 需要搭配使用， 用于线程同步</p>
</li>
<li><p>从语义角度来讲， 一个线程调用了<code>wait()</code>之后， 必然需要由另外一个线程调用<code>notify()</code>来唤醒该线程， 所以本质上， <code>wait()</code>与<code>notify()</code>的成对使用， 是一种线程间的通信手段。</p>
</li>
<li>进一步分析， <code>wait()</code> 操作的调用必然是在等待某种条件的成立， 而条件的成立必然是由其他的线程来完成的。 所以实际上， 我们调用 wait() 的时候， 实际上希望达到如下的效果</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 线程A 的代码</span></span><br><span class="line"><span class="keyword">while</span>(!condition)&#123; <span class="comment">// 不能使用 if 存疑, 因为存在一些特殊情况， 使得线程没有收到 notify 时也能退出等待状态</span></span><br><span class="line">    wait();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// do something</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 线程 B 的代码</span></span><br><span class="line"><span class="keyword">if</span>(!condition)&#123; </span><br><span class="line">    <span class="comment">// do something ...</span></span><br><span class="line">    condition = <span class="keyword">true</span>;</span><br><span class="line">    notify();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在考虑， 如果<code>wait()</code> 和 <code>notify()</code> 的操作没有相应的同步机制， 则会发生如下情况</p>
<ol>
<li>【线程A】 进入了 while 循环后突然被挂起</li>
<li>【线程B】 执行完毕了 <code>condition = true; notify();</code> 的操作， 此时【线程A】的 <code>wait()</code> 操作尚未被执行， <code>notify()</code> 操作没有产生任何效果</li>
<li>【线程A】执行<code>wait()</code> 操作， 进入等待状态，如果没有额外的 notify() 操作， 该线程将持续在 condition = true 的情形下， 持续处于等待状态得不到执行。</li>
</ol>
<p>那是否简单的将之前的代码包裹在一个 synchronized 代码块中就可以满足需求呢？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 线程A 的代码</span></span><br><span class="line"><span class="keyword">synchronized</span>(obj_A)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(!condition)&#123; </span><br><span class="line">        wait();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// do something </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 线程 B 的代码</span></span><br><span class="line"><span class="keyword">synchronized</span>(obj_A)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(!condition)&#123; </span><br><span class="line">        <span class="comment">// do something ...</span></span><br><span class="line">        condition = <span class="keyword">true</span>;</span><br><span class="line">        notify();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>乍一看， 上述的代码可以解决问题， 但是仔细分析一下， 由于<code>wait()</code> 操作会挂起当前线程， 那么必然需要在挂起前释放掉 <code>obj_A</code> 的锁， 但如果 <code>obj_A</code> 允许是任意一个指定的对象， <code>wait()</code> 操作内部必然无法得知应该释放哪个对象的锁， 除非将需要释放锁的对象作为参数传给 <code>wait()</code> 方法。那么很自然的， 语法就会被设计成 java 现在的样子。即基于对象的 <code>wait()</code> 与 <code>notify()</code> 的调用， 必须先获得该对象的锁。</p>
<p>正确的用法示例如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 线程 A 的代码</span></span><br><span class="line"><span class="keyword">synchronized</span>(obj_A)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(!condition)&#123; </span><br><span class="line">        obj_A.wait();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// do something </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 线程 B 的代码</span></span><br><span class="line">synchronized(obj_A)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(!condition)&#123; </span><br><span class="line">        <span class="comment">// do something ...</span></span><br><span class="line">        condition = <span class="literal">true</span>;</span><br><span class="line">        obj_A.notify();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="6-如何正确地使用唤醒等待机制？——-effective-java"><a href="#6-如何正确地使用唤醒等待机制？——-effective-java" class="headerlink" title="(6).如何正确地使用唤醒等待机制？—— effective java"></a>(6).如何正确地使用唤醒等待机制？—— effective java</h5><p>始终优先使用并发工具，而不是使用wait和notify，但可能必须维护使用了wait和notify的遗留代码。wait方法被用来使线程等待某个条件。必须在同步区域内部被调用，这个同步区域将对象锁定在了wait方法上的对象。下面是使用wait方法的标准模式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// The standard idiom for using the wait method，使用wait方法的标准习惯用法</span></span><br><span class="line"><span class="keyword">synchronized</span>(obj)&#123;</span><br><span class="line">    <span class="keyword">while</span>(&lt;condition does not hold&gt;)&#123; <span class="comment">//条件不成立</span></span><br><span class="line">        obj.wait(); <span class="comment">//(Release lock,and reacquire on wakeup,释放锁，重新获取的时候唤醒)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>始终应该使用wait循环模式来调用wait方法：永远不要在循环之外调用wait方法。因为循环会在等待之前和之后测试条件<strong>（基于while来反复判断进入正常操作的临界条件是否满足）</strong>。</p>
<p>在wait方法之前测试条件：当条件已经成立时就跳过等待，这对于确保活性是必要的。如果条件已经成立，并且在线程之前等待之前，notify/notifyAll 方法就已经被调用，则无法保证该线程将会从等待中苏醒过来。</p>
<p>在等待之后测试条件：如果条件不成立的话继续等待，这对于确保安全性是必要的。如果当条件不成立的时候，如果线程继续执行，则可能会破坏被锁保护的约束关系，所以我们不要这样做。当条件不成立的时候，有下面的理由可使一个线程苏醒过来：</p>
<ul>
<li>另一个线程可能已经得到了锁，并且从一个线程调用notify那一刻起，到等待线程苏醒过来的这段时间中，得到锁的线程已经改变了受保护的状态。</li>
<li>条件并不成立，但是另一个线程可能意外的或恶意的调用了notify。在公有可访问的对象上等待，这些类实际上把自己暴露在了这种危险的境地中。公有可访问对象的同步方法中包含的wait都会出现这样的问题。</li>
<li>通知线程在唤醒等待线程时可能会过度“大方”。例如，即使只有某一些等待线程的条件已经被满足，但是通知线程可能仍然调用notifyAll。</li>
<li>在没有通知的情况下，等待线程也可能（但很少）会苏醒过来。这被称为“伪唤醒”。</li>
</ul>
<p>一种常见的说法是，你总应该使用notifyAll，这是合理而保守的建议，它总会产生正确的结果，因为它可以保证你将会唤醒所有需要被唤醒的线程，你可能也会唤醒其他一些线程，但是这并不会影响程序的正确性。这些线程醒来的时候，会检查它们正在等待的条件，如果发现条件并不满足，就会继续等待。</p>
<p>从优化的角度，如果处于等待状态的所有线程都在等待同一个条件，而每次只有一个线程可以从这个条件中被唤醒，那么你就应该选择调用notify，而不是notifyAll。但即使这些条件都是真的，也许还是有理由使用notifyAll而不是notify。就好像把wait调用放在一个循环里面，以避免在公有可访问对象上的意外或恶意的通知。与此类似，使用notifyAll代替notify可以避免来自不相关线程的意外或恶意的等待。否则，这样的等待会“吞掉”一个关键的通知，使得真正接受的线程无限地等待下去。</p>
<p><strong>请看下面的例子去理解while是如何在wait前后反复检查的</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EarlyNotify</span> <span class="keyword">extends</span> <span class="title">Object</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List list;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">EarlyNotify</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        list = Collections.synchronizedList(<span class="keyword">new</span> LinkedList());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">removeItem</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        print(<span class="string">"in removeItem() - entering"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span> ( list ) &#123;</span><br><span class="line">            <span class="keyword">if</span> ( list.isEmpty() ) &#123;  <span class="comment">//这里用if语句会发生危险</span></span><br><span class="line">                print(<span class="string">"in removeItem() - about to wait()"</span>);</span><br><span class="line">                list.wait();</span><br><span class="line">                print(<span class="string">"in removeItem() - done with wait()"</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//删除元素</span></span><br><span class="line">            String item = (String) list.remove(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">            print(<span class="string">"in removeItem() - leaving"</span>);</span><br><span class="line">            <span class="keyword">return</span> item;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addItem</span><span class="params">(String item)</span> </span>&#123;</span><br><span class="line">        print(<span class="string">"in addItem() - entering"</span>);</span><br><span class="line">        <span class="keyword">synchronized</span> ( list ) &#123;</span><br><span class="line">            <span class="comment">//添加元素</span></span><br><span class="line">            list.add(item);</span><br><span class="line">            print(<span class="string">"in addItem() - just added: '"</span> + item + <span class="string">"'"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//添加后，通知所有线程</span></span><br><span class="line">            list.notifyAll();</span><br><span class="line">            print(<span class="string">"in addItem() - just notified"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        print(<span class="string">"in addItem() - leaving"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(String msg)</span> </span>&#123;</span><br><span class="line">        String name = Thread.currentThread().getName();</span><br><span class="line">        System.out.println(name + <span class="string">": "</span> + msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> EarlyNotify en = <span class="keyword">new</span> EarlyNotify();</span><br><span class="line"></span><br><span class="line">        Runnable runA = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    String item = en.removeItem();</span><br><span class="line">                    print(<span class="string">"in run() - returned: '"</span> +</span><br><span class="line">                            item + <span class="string">"'"</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> ( InterruptedException ix ) &#123;</span><br><span class="line">                    print(<span class="string">"interrupted!"</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> ( Exception x ) &#123;</span><br><span class="line">                    print(<span class="string">"threw an Exception!!!\n"</span> + x);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        Runnable runB = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                en.addItem(<span class="string">"Hello!"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//启动第一个删除元素的线程</span></span><br><span class="line">            Thread threadA1 = <span class="keyword">new</span> Thread(runA, <span class="string">"threadA1"</span>);</span><br><span class="line">            threadA1.start();</span><br><span class="line"></span><br><span class="line">            Thread.sleep(<span class="number">500</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//启动第二个删除元素的线程</span></span><br><span class="line">            Thread threadA2 = <span class="keyword">new</span> Thread(runA, <span class="string">"threadA2"</span>);</span><br><span class="line">            threadA2.start();</span><br><span class="line"></span><br><span class="line">            Thread.sleep(<span class="number">500</span>);</span><br><span class="line">            <span class="comment">//启动增加元素的线程</span></span><br><span class="line">            Thread threadB = <span class="keyword">new</span> Thread(runB, <span class="string">"threadB"</span>);</span><br><span class="line">            threadB.start();</span><br><span class="line"></span><br><span class="line">            Thread.sleep(<span class="number">10000</span>); <span class="comment">// wait 10 seconds</span></span><br><span class="line"></span><br><span class="line">            threadA1.interrupt();</span><br><span class="line">            threadA2.interrupt();</span><br><span class="line">        &#125; <span class="keyword">catch</span> ( InterruptedException x ) &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先启动threadA1，threadA1在removeItem（）中调用wait（），从而释放list上的对象锁。再过500ms，启动threadA2，threadA2调用removeItem（），获取list上的对象锁，也发现列表为空，从而在wait（）方法处阻塞，释放list上的对象锁。再过500ms后，启动threadB，并调用addItem，获得list上的对象锁，并在list中添加一个元素，同时用notifyAll通知所有线程。</p>
<pre><code>threadA1和threadA2都从wait（）返回，等待获取list对象上的对象锁，并试图从列表中删除添加的元素，这就会产生麻烦，只有其中一个操作能成功。假设threadA1获取了list上的对象锁，并删除元素成功，在退出synchronized代码块时，它便会释放list上的对象锁，此时threadA2便会获取list上的对象锁，会继续删除list中的元素，但是list已经为空了，这便会抛出IndexOutOfBoundsException。
</code></pre><p>解决办法：</p>
<p>将if换为while。重新判断是否为空，为空时继续等待挂起。</p>
<p>放在while里面，是防止出于waiting的对象被别的原因调用了唤醒方法，但是while里面的条件并没有满足（也可能当时满足了，但是由于别的线程操作后，又不满足了），就需要再次调用wait将其挂起。</p>
<p>好笑的解释：</p>
<p>如果是两个狙击手，在同时等待一个人，第一个人先打死了（改变了某个状态，不满足了条件了），第二个人还要再开一枪？针对两个线程同时等待还是要加这个while的。</p>
<p><strong>简而言之：</strong></p>
<ol>
<li>使用notify和wait就像使用“并发汇编语言”，应该在juc包下使用更高级的语言。</li>
<li>没有理由在新代码中使用wait和notify，即使有，也很少。</li>
<li>除非是维护旧的代码，那么应该利用标准的模式从while循环内部调用wait，优先使用notifyAll，如果使用notify，就一定要保证程序的活性。</li>
<li>因为wait()并不是Thread类下的函数，我们并不能使用Thread.call()。事实上很多Java程序员都喜欢这么写，因为习惯了使用Thread.sleep()，但很快他们就会发现这并不能顺利解决问题。正确的方法是对在多线程间共享的那个Object来使用wait。在生产者消费者问题中，这个共享的Object就是那个缓冲区队列。</li>
<li>既然我们应该在synchronized的函数或是对象里调用wait，那哪个对象应该被synchronized呢？答案是，那个你希望上锁的对象就应该被synchronized，即那个在多个线程间被共享的对象。</li>
<li>永远在循环（loop）里调用 wait 和 notify，不是在 If 语句！！！因为线程是在某些条件下等待的——在我们的例子里，即“如果缓冲区队列是满的话，那么生产者线程应该等待”，你可能直觉就会写一个if语句。但if语句存在一些微妙的小问题，导致即使条件没被满足，你的线程你也有可能被错误地唤醒。所以如果你不在线程被唤醒后再次使用while循环检查唤醒条件是否被满足，你的程序就有可能会出错——例如在缓冲区为满的时候生产者继续生成数据，或者缓冲区为空的时候消费者开始小号数据。</li>
<li>所以记住，永远在while循环而不是if语句中使用wait！我会推荐阅读《<a href="http://www.amazon.cn/gp/product/B001PTGR52/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&amp;camp=536&amp;creative=3200&amp;creativeASIN=B001PTGR52&amp;linkCode=as2&amp;tag=vastwork-23" target="_blank" rel="noopener">Effective Java</a>》，这是关于如何正确使用wait和notify的最好的参考资料。在while循环里使用wait的目的，是在线程被唤醒的前后都持续检查条件是否被满足。如果条件并未改变，wait被调用之前notify的唤醒通知就来了，那么这个线程并不能保证被唤醒，有可能会导致死锁问题。</li>
</ol>
<h5 id="7-为什么一定要while判断，不能用if"><a href="#7-为什么一定要while判断，不能用if" class="headerlink" title="(7).为什么一定要while判断，不能用if"></a>(7).为什么一定要while判断，不能用if</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> (monitor) &#123;</span><br><span class="line"><span class="comment">//  判断条件谓词是否得到满足*</span></span><br><span class="line"><span class="keyword">if</span>(!locked) &#123;</span><br><span class="line"><span class="comment">//  等待唤醒*</span></span><br><span class="line">monitor.wait();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//  处理其他的业务逻辑*</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果采用if判断，当线程从wait中唤醒时，那么将直接执行处理其他业务逻辑的代码，但这时候可能出现另外一种可能，条件谓词已经不满足处理业务逻辑的条件了，从而出现错误的结果，于是有必要进行再一次判断，如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> (monitor) &#123;</span><br><span class="line">    <span class="comment">//  判断条件谓词是否得到满足</span></span><br><span class="line">    <span class="keyword">if</span>(!locked) &#123;</span><br><span class="line">        <span class="comment">//  等待唤醒</span></span><br><span class="line">        monitor.wait();</span><br><span class="line">        <span class="keyword">if</span>(locked) &#123;</span><br><span class="line">            <span class="comment">//  处理其他的业务逻辑</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//  跳转到monitor.wait(); </span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="8-notify-和-notifyAll-的一段代码分析"><a href="#8-notify-和-notifyAll-的一段代码分析" class="headerlink" title="(8).notify 和 notifyAll 的一段代码分析"></a>(8).notify 和 notifyAll 的一段代码分析</h5><p>原文链接： <a href="http://stackoverflow.com/questions/37026/java-notify-vs-notifyall-all-over-again" target="_blank" rel="noopener">stackoverflow</a> 翻译： <a href="http://www.importnew.com/" target="_blank" rel="noopener">ImportNew.com </a>- <a href="http://www.importnew.com/author/songtao" target="_blank" rel="noopener">踏雁寻花</a><br>译文链接： <a href="http://www.importnew.com/10173.html" target="_blank" rel="noopener">http://www.importnew.com/10173.html</a><br>[ <strong>转载请保留原文出处、译者和译文链接。</strong>]</p>
<p>本文由 <a href="http://www.importnew.com/" target="_blank" rel="noopener">ImportNew</a> - <a href="http://www.importnew.com/author/songtao" target="_blank" rel="noopener">踏雁寻花</a> 翻译自 <a href="http://stackoverflow.com/questions/37026/java-notify-vs-notifyall-all-over-again" target="_blank" rel="noopener">stackoverflow</a>。欢迎加入<a href="http://group.jobbole.com/category/feedback/trans-team/" target="_blank" rel="noopener">翻译小组</a>。转载请见文末要求。</p>
<p>【本文已经根据网友的意见，进行了修改，考虑到网友会看不懂评论内容，我将本文的第一版发布到了博客中，点击这里 <a href="http://www.songtao.me/archives/836" target="_blank" rel="noopener">踏雁寻花</a> 可以阅读。 】</p>
<p>根据网友的意见，修改版如下：</p>
<p>当你 Google”notify() 和 notifyAll() 的区别” 时，会有大片的结果弹出来，(这里先把 jdk 的 javadoc 文档那一段撇开不说), 所有这些搜索结果归结为等待的线程被唤醒的数量：notify() 是唤醒一个, 而 notifyall() 是唤醒全部. 那他们的真正区别是什么呢?</p>
<p>让我们来看看个生产者 / 消费者的案例（假设生产者 / 消费者这个类中有两个方法 put 和 get），它是有问题的（因为这里用到了 notify 方法），是的，这段代码也许会执行，甚至大部分情况下能够正常运行，但是它也是有可能会出发生死锁，我们来看一看原因：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public synchronized <span class="keyword">void</span> put(<span class="built_in">Object</span> o) &#123;</span><br><span class="line">    <span class="keyword">while</span> ( buf.size() == MAX_SIZE) &#123;</span><br><span class="line">         wait(); <span class="comment">// 如果buffer为full，就会执行wait方法等待（为了简单，我们省略try/catch语句块）</span></span><br><span class="line">    &#125;</span><br><span class="line">    buf.add(o);</span><br><span class="line">    notify(); <span class="comment">// 通知所有正在等待对象锁的Producer和Consumer（译者注：包括被阻挡在方法外的Producer和Consumer）</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Y:这里是C2试图获取锁的地方(原作者将这个方法放到了get方法里面，此处，我把它放在了方法的外面)   </span></span><br><span class="line">public synchronized <span class="built_in">Object</span> <span class="keyword">get</span>() &#123;</span><br><span class="line">    <span class="keyword">while</span> ( buf.size() == <span class="number">0</span>) &#123;</span><br><span class="line">         wait(); <span class="comment">// 如果buffer为Null，就会执行wait方法（为了简单，同样省略try/catch语句块）</span></span><br><span class="line">          <span class="comment">// X: 这里是C1试图重新获得锁的地方（看下面代码）</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Object</span> o = buf.remove(<span class="number">0</span>);</span><br><span class="line">    notify(); <span class="comment">// 通知所有正在等待对象锁的Producer和Consumer（译者注：包括被阻挡在方法外的Producer和Consumer）</span></span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先</p>
<p><strong>我们为什么在 wait 方法外面加上 while 循环？</strong></p>
<p>我们需要使用 while 循环来实现下面的情景，</p>
<p>情景分析：</p>
<p>消费者 1（C1）进入同步块中，此时 buf 是空的，所以 C1 被放入 wait 队列中（因为执行了 wait 方法，译者注：此时 C2 是恰好到方法处，而不是因为有线程在方法中运行才被阻挡在方法外的），当消费者 2（C2）正要进入同步方法的时候 (此时在 Y 的上面)，生产者 P1 将一个对象放入到 buf 中，随后又调用 notify 方法。此时 wait 队列中唯一的线程是 C1（译者注：C2 不在 waiting 队列中，也不在 blocked 队列中），所以 C1 被唤醒，C1 被唤醒之后又开始试图重新获得对象锁，此时 C1 还在 X 的上面。</p>
<p>现在的情况是，<strong>C1 和 C2 都在试图去获取同步锁，</strong>这两个线程只能有一个被选择进入方法，另一个则会被堵塞（不是 waiting，而是 blocked 。译者注：虽然 C1 已经在方法中，不过还是会和 C2 竞争锁，如果 C2 获得锁，则 C2 进入方法执行接下来的操作，而 C1 还是继续等待锁（处于 blocked 状态）；如果 C1 获得锁，则 C1 往下执行，而 C2 还是会被挡在方法外面（处于 blocked 状态））。假如 C2 先获得了对象锁，C1 仍然被阻挡着（此时 C1 还试图在 X 处获得锁），C2 完成了方法，并释放了锁。现在 C1 获得了锁。假设这里没有 while 循环，那么 C1 就会往下执行，从 buf 中删除一个对象，但是此时 buf 中已经没有对象了，因为刚刚 C2 已经取走了一个对象，如果此时 C1 执行 buf.remove(0)，则会报 IndexArrayOutOfBoundsException 异常。为了防止这样的异常发生，我们在上面用到了 while 循环，在往下执行之前，判断此时 buf 的大小是否为 0，如果不是 0，则往下执行，如果是 0，则继续 wait()。</p>
<p><strong>那么我们这里引出问题：为什么需要 notifyAll？</strong></p>
<p>在上面生产者 - 消费者这个例子中，看起来我们用 notify 也能够侥幸成功，因为等待循环的哨兵对于消费者和生产者来说是互斥的。我们不能同时在 put 方法和 get 方法都有一个线程 wait，如果这种情况允许的话，那么下面的事情就会发生：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`buf.size() == ``<span class="number">0</span>` `AND buf.size() == MAX_SIZE (假设MAX_SIZE不为``<span class="number">0</span>``)`</span><br></pre></td></tr></table></figure>
<p>然而，这样并不好，我们需要使用 notifyAll。让我们来看一看原因：</p>
<p>假设 buffer=1（为了更加容易理解），按照下面的步骤执行将会发生死锁。要注意的是：notify 可以唤醒任何一个线程，不过 JVM 不能确定是哪个线程被唤醒，所以，任何一个线程都有被唤醒的可能。另外要注意的是，当多个线程被阻塞在方法外的时候（在试图获得锁），获得锁的顺序也是不确定的。要记住，在任何时候，方法中只能有一个线程存在 - 在类中任何同步的方法只允许一个线程执行（这个线程要持有对象锁才可以执行）。如果下面的执行顺序发生了的话，就会导致死锁：</p>
<p>第一步：P1 放入一个对象到 buffer 中；<br>第二步：P2 试图 put 一个对象，此时 buf 中已经有一个了，所以 wait<br>第三步：P3 试图 put 一个对象，仍然 wait<br>第四步：</p>
<ul>
<li>C1 试图从 buf 中获得一个对象；</li>
<li>C2 试图从 buf 中获得一个对象，但是挡在了 get 方法外面</li>
<li>C3 试图从 buf 中获得一个对象，同样挡在了 get 方法外面</li>
</ul>
<p>第五步：</p>
<ul>
<li>C1 执行完 get 方法，执行 notify，退出方法</li>
<li>notify 唤醒了 P2，</li>
<li>但是 C2 在 P2 唤醒之前先进入了 get 方法，所以 P2 必须再次获得锁，P2 被挡在了 put 方法的外面，</li>
<li>C2 循环检查 buf 大小，在 buf 中没有对象，所以只能 wait；</li>
<li>C3 在 C2 之后，P2 之前进入了方法，由于 buf 中没有对象，所以也 wait；</li>
</ul>
<p>第六步：</p>
<ul>
<li>现在，有 P3，C2，C3 在 waiting；</li>
<li>最后 P2 获得了锁，在 buf 中放入了一个对象，执行 notify，退出 put 方法；</li>
</ul>
<p>第七步：</p>
<ul>
<li>notify 唤醒 P3；</li>
<li>P3 检查循环条件，在 buf 中已经有了一个对象，所以 wait；</li>
<li>现在没有线程能够 notify 了，三个线程就会处于死锁状态。</li>
</ul>
<p>下面是译者分析：</p>
<p> <strong>那么如果使用 notifyAll 方法唤醒线程，又会怎样呢？</strong></p>
<p>在执行第五步时，即 C1 执行完 get 方法后，又执行了 notifyAll 方法，此时，notifyAll 方法会唤醒所有正在等待该锁的线程，那么所有的线程都会处于运行前的<strong>准备状态（此时不是 wait 状态）</strong>，此时，即使 C2 在 P2(此时 P2 已经被唤醒，P3 也被唤醒，处于准备状态，而不是 wait 状态) 之前先进入了 get 方法，C2 循环检查 buf 大小，在 buf 中没有对象，所以进入 wait 状态；C3 在 C2 之后，P2 之前进入方法，由于 buf 中没有对象，所以也 wait；（这里重新分析了一下步骤五发生的情景）</p>
<p>第六步：现在，有 C2，C3 在 waiting，P3 在第五步已经被唤醒了，处于准备状态，此时，如果 P2 获得锁，在 buf 中放入一个对象，执行 notifyAll，又将 C2、C3 唤醒了；</p>
<p>第七步：此时，P3 检查循环条件，在 buf 中已经有了一个对象，所以 wait，不过此时并不会发生死锁，因为 C2 和 C3 还会继续执行。</p>
<p>总结：notify 方法很容易引起死锁，除非你根据自己的程序设计，确定不会发生死锁，notifyAll 方法则是线程的安全唤醒方法。</p>
<p>附：<br>notify 和 notifyAll 的区别：<br>notify() 和 notifyAll() 都是 Object 对象用于通知处在等待该对象的线程的方法。<br>void notify(): 唤醒一个正在等待该对象的线程。<br>void notifyAll(): 唤醒所有正在等待该对象的线程。<br>两者的最大区别在于：</p>
<p>notifyAll 使所有原来在该对象上等待被 notify 的线程统统退出 wait 的状态，变成等待该对象上的锁，一旦该对象被解锁，他们就会去竞争。<br>notify 他只是选择一个 wait 状态线程进行通知，并使它获得该对象上的锁，但不惊动其他同样在等待被该对象 notify 的线程们，当第一个线程运行完毕以后释放对象上的锁，此时如果该对象没有再次使用 notify 语句，即便该对象已经空闲，其他 wait 状态等待的线程由于没有得到该对象的通知，继续处在 wait 状态，直到这个对象发出一个 notify 或 notifyAll，它们等待的是被 notify 或 notifyAll，而不是锁。</p>
<p>以前大伙看到这两个区别的时候可能感觉到很懵，相信现在应该有些明白了吧，如果还没有搞清楚可以看一下我这里案例的分析：<a href="http://blog.csdn.net/tayanxunhua/article/details/20998449" target="_blank" rel="noopener">notify 发生死锁的情景</a></p>
<p><strong>根据网友的评论补充：</strong></p>
<p>解释下前三步：<br>synchronized 修饰的方法，同一时刻只能允许一个线程进入，所以第一步执行之后，P1 执行 notify，跳出方法，然后，P2 可以进入 synchronized 修饰的 put 方法，不过这一次是 wait，P2 线程会释放对象锁，此时 P3 就可以进入 put 方法，当然了，还是 wait()，释放了对象锁。<br>第四步：<br>get 方法也是用 synchronized 修饰的，所以同一时刻，只能有一个线程进入此方法，C1 进入之后，试图取走一个对象，但此时还没有取走，此时，C2 准备进入 get 方法，不过因为这个方法是用 synchronized 修饰的，所以 C2 被挡在了方法的外面，同理，C3 也被挡在了方法的外面。（注意：此时 C1 还没有取走对象）。</p>
<p>第五步：<br>当 C1 取走对象后，在执行 notify 方法之前，P2，P3 会继续 wait，继续等着 notify 的通知。<br>C1 执行 notify 方法，通知了 P2，此时 P2 可以获得对象锁了（这里的意思是说: P2 可以去抢对象锁了，但是能不能抢得到就看它的造化了）。（注意：此时的 C2 以及 C3 还在外面等着，不过它们不是因为执行了 wait 而等，所以它们不需要等 notify 的通知，只要有对象锁，它们两个就可以争抢，获得了对象锁的就可以进入方法，所以，虽然 notify 通知了 P2，但是 C2 和 P2 同属竞争关系，所以 C2 是可以在 P2 之前获得对象锁的）。</p>
<p>网友补充：</p>
<p>C2，C3 在 C1 进入 get 方法后会被 jvm 放入对象的锁池中，而 P2，P3 是被放入对象的等待池中，等待池的线程只有通过 notify、notifyAll 或者 interrupt 才能进入锁池中，而锁池的线程只有拿到锁标识后才进入 runnable 状态等待 cpu 时间片。</p>
<h5 id="9-延伸出来的生产者与消费者问题"><a href="#9-延伸出来的生产者与消费者问题" class="headerlink" title="(9).延伸出来的生产者与消费者问题"></a>(9).延伸出来的生产者与消费者问题</h5><p>生产者-消费者（producer-consumer）问题，也称作有界缓冲区（bounded-buffer）问题，两个进程共享一个公共的固定大小的缓冲区。</p>
<p>其中一个是生产者，用于将消息放入缓冲区；另外一个是消费者，用于从缓冲区中取出消息。问题出现在当缓冲区已经满了，而此时生产者还想向其中放入一个新的数据项的情形，其解决方法是让生产者此时进行休眠，等待消费者从缓冲区中取走了一个或者多个数据后再去唤醒它。同样地，当缓冲区已经空了，而消费者还想去取消息，此时也可以让消费者进行休眠，等待生产者放入一个或者多个数据时再唤醒它。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProducerConsumer</span> </span>&#123; <span class="comment">//生产者与消费者问题</span></span><br><span class="line">    <span class="keyword">private</span> LinkedList&lt;Object&gt; storeHouse = <span class="keyword">new</span> LinkedList&lt;Object&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> MAX = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ProducerConsumer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Producer().start();</span><br><span class="line">        <span class="keyword">new</span> Comsumer().start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Producer</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;		<span class="comment">//生产者</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (storeHouse) &#123;	<span class="comment">//对公共资源进行加锁</span></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">while</span> (storeHouse.size() == MAX) &#123;</span><br><span class="line">                            System.out.println(<span class="string">"storeHouse is full , please wait"</span>);</span><br><span class="line">                            storeHouse.wait();		<span class="comment">//注意while判断的条件，必须使用while，不然会造成异常</span></span><br><span class="line">                        &#125;</span><br><span class="line">                        Object newOb = <span class="keyword">new</span> Object();</span><br><span class="line">                        <span class="keyword">if</span> (storeHouse.add(newOb)) &#123;</span><br><span class="line">                            System.out.println(<span class="string">"Producer put a Object to storeHouse"</span>);</span><br><span class="line">                            Thread.sleep((<span class="keyword">long</span>) (Math.random() * <span class="number">3000</span>));</span><br><span class="line">                            storeHouse.notify();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException ie) &#123;</span><br><span class="line">                        System.out.println(<span class="string">"producer is interrupted!"</span>);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Comsumer</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (storeHouse) &#123;	<span class="comment">//同样也是对公共资源进行加锁</span></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">while</span> (storeHouse.size() == <span class="number">0</span>) &#123;	<span class="comment">//while循环条件</span></span><br><span class="line">                            System.out.println(<span class="string">"storeHouse is empty , please wait"</span>);</span><br><span class="line">                            storeHouse.wait();</span><br><span class="line">                        &#125;</span><br><span class="line">                        storeHouse.removeLast();	</span><br><span class="line">                        System.out.println(<span class="string">"Comsumer get  a Object from storeHouse"</span>);</span><br><span class="line">                        Thread.sleep((<span class="keyword">long</span>) (Math.random() * <span class="number">3000</span>));</span><br><span class="line">                        storeHouse.notify();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException ie) &#123;</span><br><span class="line">                        System.out.println(<span class="string">"Consumer is interrupted"</span>);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Produc	erConsumer pc = <span class="keyword">new</span> ProducerConsumer();</span><br><span class="line">        pc.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>原文链接： <a href="http://www.importnew.com/16453.html" target="_blank" rel="noopener">javarevisited</a> 翻译： <a href="http://www.importnew.com/" target="_blank" rel="noopener">ImportNew.com </a>- <a href="http://www.importnew.com/author/bolefanyi" target="_blank" rel="noopener">伯乐在线翻译组</a><br>译文链接： <a href="http://www.importnew.com/16453.html" target="_blank" rel="noopener">http://www.importnew.com/16453.html</a><br>[ <strong>转载请保留原文出处、译者和译文链接。</strong>]</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第二份生产者消费者代码 http://www.importnew.com/16453.html</span></span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList; </span><br><span class="line"><span class="keyword">import</span> java.util.Queue; </span><br><span class="line"><span class="keyword">import</span> java.util.Random; </span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment">* Simple Java program to demonstrate How to use wait, notify and notifyAll() </span></span><br><span class="line"><span class="comment">* method in Java by solving producer consumer problem.</span></span><br><span class="line"><span class="comment">* </span></span><br><span class="line"><span class="comment">* <span class="doctag">@author</span> Javin Paul </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProducerConsumerInJava</span> </span>&#123; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123; </span><br><span class="line">        System.out.println(<span class="string">"How to use wait and notify method in Java"</span>); </span><br><span class="line">        System.out.println(<span class="string">"Solving Producer Consumper Problem"</span>); </span><br><span class="line">        Queue&amp;lt;Integer&amp;gt; buffer = <span class="keyword">new</span> LinkedList&amp;lt;&amp;gt;(); </span><br><span class="line">        <span class="keyword">int</span> maxSize = <span class="number">10</span>; </span><br><span class="line">        Thread producer = <span class="keyword">new</span> Producer(buffer, maxSize, <span class="string">"PRODUCER"</span>); </span><br><span class="line">        Thread consumer = <span class="keyword">new</span> Consumer(buffer, maxSize, <span class="string">"CONSUMER"</span>); </span><br><span class="line">        producer.start(); consumer.start(); &#125; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">    * Producer Thread will keep producing values for Consumer </span></span><br><span class="line"><span class="comment">    * to consumer. It will use wait() method when Queue is full </span></span><br><span class="line"><span class="comment">    * and use notify() method to send notification to Consumer </span></span><br><span class="line"><span class="comment">    * Thread. </span></span><br><span class="line"><span class="comment">    * </span></span><br><span class="line"><span class="comment">    * <span class="doctag">@author</span> WINDOWS 8 </span></span><br><span class="line"><span class="comment">    * </span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Producer</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span></span><br><span class="line"><span class="class">    </span>&#123; <span class="keyword">private</span> Queue&amp;lt;Integer&amp;gt; queue; </span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> maxSize; </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Producer</span><span class="params">(Queue&amp;lt;Integer&amp;gt; queue, <span class="keyword">int</span> maxSize, String name)</span></span>&#123; </span><br><span class="line">            <span class="keyword">super</span>(name); <span class="keyword">this</span>.queue = queue; <span class="keyword">this</span>.maxSize = maxSize; </span><br><span class="line">        &#125; </span><br><span class="line">        <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">        </span>&#123; </span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) </span><br><span class="line">                &#123; </span><br><span class="line">                    <span class="keyword">synchronized</span> (queue) &#123; </span><br><span class="line">                        <span class="keyword">while</span> (queue.size() == maxSize) &#123; </span><br><span class="line">                            <span class="keyword">try</span> &#123; </span><br><span class="line">                                System.out .println(<span class="string">"Queue is full, "</span> + <span class="string">"Producer thread waiting for "</span> + <span class="string">"consumer to take something from queue"</span>); </span><br><span class="line">                                queue.wait(); </span><br><span class="line">                            &#125; <span class="keyword">catch</span> (Exception ex) &#123; </span><br><span class="line">                                ex.printStackTrace(); &#125; </span><br><span class="line">                            &#125; </span><br><span class="line">                            Random random = <span class="keyword">new</span> Random(); </span><br><span class="line">                            <span class="keyword">int</span> i = random.nextInt(); </span><br><span class="line">                            System.out.println(<span class="string">"Producing value : "</span> + i); queue.add(i); queue.notifyAll(); </span><br><span class="line">                        &#125; </span><br><span class="line">                    &#125; </span><br><span class="line">                &#125; </span><br><span class="line">            &#125; </span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">    * Consumer Thread will consumer values form shared queue. </span></span><br><span class="line"><span class="comment">    * It will also use wait() method to wait if queue is </span></span><br><span class="line"><span class="comment">    * empty. It will also use notify method to send </span></span><br><span class="line"><span class="comment">    * notification to producer thread after consuming values </span></span><br><span class="line"><span class="comment">    * from queue. </span></span><br><span class="line"><span class="comment">    * </span></span><br><span class="line"><span class="comment">    * <span class="doctag">@author</span> WINDOWS 8 </span></span><br><span class="line"><span class="comment">    * </span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123; </span><br><span class="line">        <span class="keyword">private</span> Queue&amp;lt;Integer&amp;gt; queue; </span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> maxSize; </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Consumer</span><span class="params">(Queue&amp;lt;Integer&amp;gt; queue, <span class="keyword">int</span> maxSize, String name)</span></span>&#123; </span><br><span class="line">            <span class="keyword">super</span>(name); </span><br><span class="line">            <span class="keyword">this</span>.queue = queue; </span><br><span class="line">            <span class="keyword">this</span>.maxSize = maxSize; </span><br><span class="line">        &#125; </span><br><span class="line">        <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123; </span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123; </span><br><span class="line">                <span class="keyword">synchronized</span> (queue) &#123; </span><br><span class="line">                    <span class="keyword">while</span> (queue.isEmpty()) &#123; </span><br><span class="line">                        System.out.println(<span class="string">"Queue is empty,"</span> + <span class="string">"Consumer thread is waiting"</span> + <span class="string">" for producer thread to put something in queue"</span>); </span><br><span class="line">                        <span class="keyword">try</span> &#123; </span><br><span class="line">                            queue.wait(); </span><br><span class="line">                        &#125; <span class="keyword">catch</span> (Exception ex) &#123; </span><br><span class="line">                            ex.printStackTrace(); </span><br><span class="line">                        &#125; </span><br><span class="line">                    &#125; </span><br><span class="line">                    System.out.println(<span class="string">"Consuming value : "</span> + queue.remove()); queue.notifyAll(); </span><br><span class="line">                &#125; </span><br><span class="line">            &#125; </span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//为了更好地理解这个程序，我建议你在debug模式里跑这个程序。一旦你在debug模式下启动程序，它会停止在PRODUCER或者CONSUMER线程上，取决于哪个线程占据了CPU。因为两个线程都有wait()的条件，它们一定会停止，然后你就可以跑这个程序然后看发生什么了（很有可能它就会输出我们以上展示的内容）。你也可以使用Eclipse里的Step into和Step over按钮来更好地理解多线程间发生的事情。</span></span><br></pre></td></tr></table></figure>
<p>这是关于Java里如何使用wait, notify和notifyAll的所有重点啦。你应该只在你知道自己要做什么的情况下使用这些函数，不然Java里还有很多其它的用来解决同步问题的方案。例如，如果你想使用生产者消费者模型的话，你也可以使用BlockingQueue，它会帮你处理所有的线程安全问题和流程控制。如果你想要某一个线程等待另一个线程做出反馈再继续运行，你也可以使用<a href="http://java67.blogspot.sg/2015/06/how-to-use-cyclicbarrier-in-java.html" target="_blank" rel="noopener">CycliBarrier或者CountDownLatch</a>。如果你只是想保护某一个资源的话，你也可以使用Semaphore。</p>
<h4 id="三-Object里面的finalize方法"><a href="#三-Object里面的finalize方法" class="headerlink" title="三. Object里面的finalize方法"></a>三. Object里面的finalize方法</h4><p>​    终结方法通常是不可预测的，也是很危险的，一般情况下是不必要的。使用终结方法会导致行为不稳定，降低性能，以及可移植性问题。当然终结方法也有其用处，我们在本条目的最后在做介绍，<strong>但是根据经验，应该避免使用终结方法</strong></p>
<p>​    在java中当一个对象不可达的时候，垃圾回收器会回收与该对象相关联的存储空间。并不需要程序员做相关的工作。C++的析构器也可以被用来回收其他的非内存资源。<strong>而在java中，会用try-finally来完成类似的工作。</strong></p>
<p>​    <strong>行为不稳定，降低性能：</strong></p>
<p>​    终结方法的缺点在于不能保证会被及时地执行。从一个对象变得不可到达开始到它的终结方法被执行，所花费的时间是任意长的。<strong>这意味着，注重时间的任务不应该由终结方法来完成。</strong></p>
<p>​    比如用终结方法来关闭已经被打开的文件，这是严重的错误，因为打开文件的描述符是很有限的一种资源。由于JVM会延迟执行终结方法，所有大量的文件会保留在打开的状态，当一个程序再不能打开文件的时候，可能会运行失败。</p>
<p>​    <strong>可移植性问题：</strong></p>
<p>​    及时地执行终结方法正是垃圾回收算法的一个主要功能，这种算法在不同的 JVM 实现起来会大相径庭。如果程序依赖终结方法执行的时间点，那么这个程序的行为在不同的 JVM 上表现可能会截然不同。在你测试用的 JVM 上表现的很好，但是在用户的 JVM 上可能无法运行。</p>
<p>​    <strong>严重的性能损失：</strong></p>
<p>​    销毁一个简单对象的时间约为5.6ns。增加一个终结方法使时间增加到了2400ns，换句话说，用终结方法创建和销毁对象慢了大约430倍。</p>
<hr>
<p>​    <strong>延迟终结过程并不只是一个理论的问题。在很少见的情况下，为类提供终结方法，可能会随意地延迟其实例的回收过程。</strong>一个同事调试一个长期运行的GUI应用程序时，出现了OOM错误死掉了，分析显示，该程序的终结队列方法有数千个图形对象正在等待终结或者被回收。但是终结方法线程的优先级比该应用程序的其他线程要低得多，所以图形对象的终结速度达不到他们进入队列的速。<strong>Java语言规范并不保证哪个线程将会执行终结方法，所以除了不使用终结方法之外，并没有很轻便的方法，能够避免这样对待问题。</strong></p>
<p>​    Java语言规范不仅不保证终结方法会被及时地执行，而且根本不保证他们会被执行，一个程序终止的时候，某些已经无法访问的对象上的终结方法却根本没有执行，这是完全可能的。<strong>结论是：不应该依赖终结方法来更新重要的持久状态。</strong>例如，依赖终结方法来释放共享资源（比如数据库）上的永久锁，很容易让整个分布式系统垮掉。</p>
<p>​    不要被System.gc/System.runFinalization两个方法所诱惑，他们确实增加了终结方法被执行的机会，但是他们并不保证终结方法一定会被执行。</p>
<p>​    还有一种值的考虑的情况，如果未被捕获的异常在终结过程中被抛出来，那么这种异常可以被忽略，并且该对象的终结过程也会终止。未捕获的异常会使对象处于破坏的状态，如果另一个线程企图用这种被破坏的对象，则可能发生任何不确定的行为。<strong>正常情况下，未被捕获的异常将会使线程终止，并打印出栈轨迹，但是，如果异常发生在终结方法之中，则不会如此，甚至连警告都不会打印出来。</strong></p>
<hr>
<p><strong>一些确实需要用到终结方法的时候：</strong></p>
<p>​    当类的对象中封装的资源（如文件或者线程）确实需要终止，应该怎么做才能不用编写终结方法呢？</p>
<ul>
<li><p><strong>只需要提供一个显式的终结方法</strong>，并且要求类的客户端在每个实例不在有用的时候调用这个方法。</p>
</li>
<li><p><strong>值的一提的细节是，该实例必须记录自己是否已经被终止了</strong>：显示的终止方法必须在一个私有域中记录下：“该对象已经不再有效”。</p>
</li>
<li><p><strong>如果这些方法是在对象已经终止之后被调用，其他的方法就必须检查这个域</strong>，并抛出IllegalStateException异常。</p>
<p>典型的例子就是：InputStream ,OutputStream和 java.sql.Connection上的close方法。另一个例子就是java.util.Timer上的cancel方法，它执行必要的状态改变，使得与Timer实例相关联的线程温和地终止自己。</p>
</li>
</ul>
<p>  显示的终止方法通常与try-finally结构结合起来使用，以确保及时终止。在finally子句内部调用显示的终止方法，可以保证即使在使用对象的时候有异常抛出，该终止方法也会执行</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// try-finally block guarantees execution of termination method</span></span><br><span class="line">Foo foo = <span class="keyword">new</span> Foo(...);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// Do what must be done with foo</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">   foo.terminate(); <span class="comment">// Explicit termination method</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  使用终结方法的好处：</p>
<p>  <strong>第一种用途是，当对象的所有者忘记调用前面段落中建议的显示终止方法时，终结方法可以充当“安安全网”（safety net）</strong></p>
<p>  ​    虽然这样做并不能保证终结方法会被及时地调用，但是在客户端无法通过电泳显示的终止方法来正常结束操作的情况下（希望这种情形尽可能的少发生），迟一点释放关键资源总比永远不释放要好。<strong>但是如果终结方法发现资源还未被终止，则应该在日志中记录一条警告</strong>，因为这表示客户端代码中的一个Bug，应该得到修复。</p>
<p>  ​    显示终止方法模式的示例中所示的四个类（FileInputStream、FileOutputStream、Timer和Connection），都具有终结方法，当他们的终止方法未能被调用的情况下，这些终结方法充当了安全网。</p>
<hr>
<p>  <strong>终结方法的第二种合理用途与对象的本地对等体（native peer）有关。</strong></p>
<p>  ​    <strong>本地对等体是一个本地对象（native object）</strong>，普通对象通过本地方法（native method）委托给一个本地对象。因为本地对等体不是一个普通对象，所以垃圾回收器不会知道它，当它的Java对等体被回收的时候，他不会被回收。</p>
<p>  ​    在本地对等体并不拥有关键资源的前提下，终结方法正是执行这项任务最合适的工具。如果本地对等体拥有必须被即使终止的资源，那么该类就应该具有一个显示地终止方法，如前所述。终止方法应该完成所有必要的工作以便释放关键的资源。终止方法可以是本地方法，或者他也可以调用本地方法。</p>
<p>  ​    值得注意的很重要一点是，“终结方法链（finalizer chaining）”并不会被自动执行。如果类（不是Object）有终结方法，并且子类覆盖了终结方法，子类的终结方法就必须手工调用超类的终结方法。</p>
<p>  ​    <strong>你应该在一个try块中终结子类，子类的终结方法就必须手工调用超类的终结方法。你应该在一个try块中终结子类，并在相应的finally块中调用超类的终结方法。</strong>这样做可以保证：即使子类的终结过程抛出异常，常磊的终结方法也会得到执行，反之亦然。</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Manual finalizer chaining</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span> </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">    ... <span class="comment">// Finalize subclass state</span></span><br><span class="line"></span><br><span class="line"> &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">super</span>.finalize();</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  ​    如果子类实现者覆盖了超类的终结方法，但是忘了手工调用超类的终结方法（或者有意选择不调用超类的终结方法），那么超类的终结方法将永远也不会被调用到。要防范这样粗心大意或者恶意的子类是有可能的，代价就是为每个将被终结的对象创建一个附加的对象。</p>
<p>  ​    不是把终结方法放在要求终结处理的类中，而是把终结方法方在一个匿名的类中，该匿名类的唯一用途就是终结它的外围实例（enclosing instance）。该匿名类的<strong>单个实例被称为终结方法守卫者（finalizer guardian）</strong>，外围类的每个实例都会创建这样一个守卫者。外围实例在它的私有实例中保存着一个对其终结方法守卫者的唯一引用，因此终结方法守卫者与外围实例可以同时启动终结过程。当守卫者被终结的时候，它执行外围实例所期望的终结行为，就好像它的终结方法是外围对象上的一个方法一样：    </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Finalizer Guardian idiom</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Sole purpose of this object is to finalize outer Foo object</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">final</span> Object finalizerGuadian = <span class="keyword">new</span> Object() &#123;</span><br><span class="line">	<span class="meta">@Override</span> <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">		... <span class="comment">// Finalize outer Foo object</span></span><br><span class="line">		&#125;</span><br><span class="line"> &#125;;</span><br><span class="line">	... <span class="comment">//Remainder omitted</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​    注意，共有类Foo并没有终结方法（除了它从Object继承了一个无关紧要的之外），所以子类的终结方法是否调用super.finalize并不重要。对于每一个带有终结方法的非final公有类，都应该考虑使用这种方法。    </p>
<p><strong>小结：</strong>            </p>
<p>​    总之，除非是作为安全网，或者是为了终止非关键的本地资源，否则请不要使用终结方法。</p>
<p>​    在这些很少见的情况下，既然使用了终结方法，就要记住调用super.finalize。</p>
<p>​    如果用终结方法作为安全网，要记得记录终结方法的非法用法。</p>
<p>​    最后，如果需要把终结方法与公有的非final类关联起来，请考虑使用终结方法守卫者，以确保即使子类的终结方法未能调用super.finalize，该终结方法也会被执行                                                                    摘抄自——《Effective Java》</p>
<h4 id="四-参考代码"><a href="#四-参考代码" class="headerlink" title="四. 参考代码"></a>四. 参考代码</h4><h5 id="（1）线程相互通信，这是一个有缺点的案例，使用wait前，最好需要加上while循环"><a href="#（1）线程相互通信，这是一个有缺点的案例，使用wait前，最好需要加上while循环" class="headerlink" title="（1）线程相互通信，这是一个有缺点的案例，使用wait前，最好需要加上while循环"></a>（1）线程相互通信，这是一个有缺点的案例，使用wait前，最好需要加上while循环</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WaitNotifyDemo</span> </span>&#123;   <span class="comment">//线程间相互通信的例子</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">static</span> Object lock = <span class="keyword">new</span> Object();   <span class="comment">//一个lock的对象</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"线程A等待拿锁"</span>);</span><br><span class="line">                <span class="keyword">synchronized</span> (lock)&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        System.out.println(<span class="string">"线程A拿到锁了"</span>);</span><br><span class="line">                        TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">                        System.out.println(<span class="string">"线程A开始等待并且放弃锁了"</span>);</span><br><span class="line">                        lock.wait();</span><br><span class="line">                        System.out.println(<span class="string">"被通知可以继续执行，则运行到结束"</span>);</span><br><span class="line">                    &#125;<span class="keyword">catch</span> (InterruptedException e)&#123;</span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">"线程A"</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"线程B等待拿锁"</span>);</span><br><span class="line">                <span class="keyword">synchronized</span> (lock)&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        System.out.println(<span class="string">"线程B拿到锁了"</span>);</span><br><span class="line">                        TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">                    &#125;<span class="keyword">catch</span> (InterruptedException e)&#123;</span><br><span class="line">                    &#125;</span><br><span class="line">                    lock.notify();</span><br><span class="line">                    System.out.println(<span class="string">"线程B随机通知某个线程"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">"线程B"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果分析：</p>
<p>多次执行代码存在两种情况</p>
<p>1.顺利成功执行代码，其中sleep的过程，为其中红色划线处，A线程等待拿锁，B线程也等待拿锁，且线程A拿到了锁。开始执行线程A中的代码，然后sleep，让出cpu，但是线程B也无法继续执行，因为它缺少对象锁，sleep到了之后，线程A继续执行，调用wait方法，放弃对象锁，进入等待池，此时B拿到了锁，进入sleep，然后调用notify方法（注意此时还没有释放锁），通知A，此时等待池只有A线程在里面，输出”线程B随机通知某个线程”，然后退出同步代码块，释放对象锁。线程A又拿到了对象锁，继续执行。</p>
<p><img src="D:\BackupHexo\source\img\Object\mark1.png" alt></p>
<p>2.不顺利地执行代码，B拿到锁了，进入sleep方法，让出cpu执行权，但是线程A没有对象锁，还是无法执行，线程B调用notify方法，但此时等待池没有等待的线程（存在疑问），输出”线程B随机通知某个线程”，退出同步代码块，释放对象锁，此时A得到了对象锁，进入sleep方法，让出cpu，sleep方法结束之后，线程A开始等待并且放弃锁了，调用wait方法，但是没有人通知它，所以一直在等待池等待。</p>
<p><img src="D:\BackupHexo\source\img\Object\mark2.png" alt></p>
<h5 id="（2）notify使用不当造成死锁"><a href="#（2）notify使用不当造成死锁" class="headerlink" title="（2）notify使用不当造成死锁"></a>（2）notify使用不当造成死锁</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WaitNotifyDemo2</span> </span>&#123;  	<span class="comment">//notify使用不当导致的死锁问题</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// System.out.println("lock");</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> OutTurn ot = <span class="keyword">new</span> OutTurn();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">100</span>; j++) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="comment">// try &#123;</span></span><br><span class="line">                    <span class="comment">// Thread.sleep(10);</span></span><br><span class="line">                    <span class="comment">// &#125; catch (InterruptedException e) &#123;</span></span><br><span class="line">                    <span class="comment">// e.printStackTrace();</span></span><br><span class="line">                    <span class="comment">// &#125;</span></span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">                        ot.sub();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="comment">// try &#123;</span></span><br><span class="line">                    <span class="comment">// Thread.sleep(10);</span></span><br><span class="line">                    <span class="comment">// &#125; catch (InterruptedException e) &#123;</span></span><br><span class="line">                    <span class="comment">// e.printStackTrace();</span></span><br><span class="line">                    <span class="comment">// &#125;</span></span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">                        ot.main();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OutTurn</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> isSub = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">sub</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (!isSub ) &#123;</span><br><span class="line">                <span class="keyword">this</span>.wait();</span><br><span class="line">            &#125;</span><br><span class="line">            System. out.println(<span class="string">"sub ---- "</span> + count);</span><br><span class="line">            isSub = <span class="keyword">false</span> ;</span><br><span class="line">            <span class="keyword">this</span>.notify();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        count++;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (isSub ) &#123;</span><br><span class="line">                <span class="keyword">this</span>.wait();</span><br><span class="line">            &#125;</span><br><span class="line">            System. out.println(<span class="string">"main (((((((((((( "</span> + count);</span><br><span class="line">            isSub = <span class="keyword">true</span> ;</span><br><span class="line">            <span class="keyword">this</span>.notify();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>解释一下原因：</p>
<p>​     OutTurn类中的sub和main方法都是同步方法，所以多个调用sub和main方法的线程都会处于阻塞状态，等待一个正在运行的线程来唤醒它们。下面分别分析一下使用notify和notifyAll方法唤醒线程的不同之处：</p>
<p>​     上面的代码使用了notify方法进行唤醒，而notify方法只能唤醒一个线程，其它等待的线程仍然处于wait状态，假设调用sub方法的线程执行完后（即System. <em>out</em> .println(“sub —- “ + count )执行完之后），所有的线程都处于等待状态，此时在sub方法中的线程执行了isSub=false语句后又执行了notify方法，<strong>这时如果唤醒的是一个sub方法的调度线程</strong>，那么while循环等于true，则此唤醒的线程也会处于等待状态，此时所有的线程都处于等待状态，那么也就没有了运行的线程来唤醒它们，这就发生了死锁。</p>
<p>​     如果使用notifyAll方法来唤醒所有正在等待该锁的线程，那么所有的线程都会处于运行前的<strong>准备状态</strong>（就是sub方法执行完后，唤醒了所有等待该锁的状态,注：<strong>不是wait状态</strong>），那么此时，<strong>即使再次唤醒一个sub方法调度线程</strong>，while循环等于true，唤醒的线程再次处于等待状态，<strong>那么</strong>还会有其它的线程可以获得锁，进入运行状态。</p>
<p>​     总结：notify方法很容易引起死锁，除非你根据自己的程序设计，确定不会发生死锁，notifyAll方法则是线程的安全唤醒方法，<strong>代码造成死锁的原因就是notify是随意唤醒一个线程，唤醒的可能是功能相同的线程，而锁并不在唤醒的线程手里，就造成了死锁的产生。</strong></p>
<h5 id="（3）虚假唤醒（原文章已经过修改-参考链接见下方）"><a href="#（3）虚假唤醒（原文章已经过修改-参考链接见下方）" class="headerlink" title="（3）虚假唤醒（原文章已经过修改,参考链接见下方）"></a>（3）虚假唤醒（原文章已经过修改,参考链接见下方）</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyStack</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(String value)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;  </span><br><span class="line">            list.add(value);  </span><br><span class="line">            notify();  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> String <span class="title">pop</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;  </span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;  </span><br><span class="line">            <span class="keyword">if</span> (list.size() &lt;= <span class="number">0</span>) &#123;  </span><br><span class="line">                wait();  </span><br><span class="line">            &#125;  </span><br><span class="line">            <span class="keyword">return</span> list.remove(list.size() - <span class="number">1</span>);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码大多数情况下运行正常，但是某些情况下会出问题</p>
<p>代码分析：</p>
<p>从整体上，在并发状态下，push和pop都使用了synchronized的锁，来实现同步，同步的数据对象是基于List的数据；大部分情况下是可以正常工作的。</p>
<p>问题描述：</p>
<p>状况1：</p>
<ol>
<li><p><strong>假设有三个线程： A,B,C.  A 负责放入数据到list,就是调用push操作， B,C分别执行Pop操作，移除数据。</strong></p>
</li>
<li><p><strong>首先B先执行，于pop中的wait()方法处，进入waiting状态，进入等待队列，释放锁。</strong></p>
</li>
<li><p><strong>A首先执行放入数据push操作到List，在调用notify()之前； 同时C执行pop()，由于synchronized，被阻塞，进入Blocked状态，放入基于锁的等待队列。注意，这里的队列和2中的waiting等待队列是两个不同的队列。</strong></p>
</li>
<li><p><strong>A线程调用notify()，唤醒等待中的线程B。</strong></p>
</li>
<li><p><strong>如果此时， C获取到基于对象的锁，则优先执行，执行pop方法，获取数据，从list移除一个元素。</strong></p>
</li>
<li><p><strong>然后，B获取到竞争锁，B中调用list.remove(list.size() - 1)，则会报数据越界exception。</strong></p>
</li>
</ol>
<p>状况2：</p>
<ol>
<li><p><strong>相同于状况1</strong></p>
</li>
<li><p><strong>B、C都处于等待waiting状态，释放锁。等待notify()、notifyAll()操作的唤醒。</strong></p>
</li>
<li><p><strong>存在被虚假唤醒的可能。</strong></p>
</li>
</ol>
<p>何为虚假唤醒？</p>
<p><strong>虚假唤醒就是一些obj.wait()会在除了obj.notify()和obj.notifyAll()的其他情况被唤醒，而此时是不应该唤醒的。</strong></p>
<p><strong>解决的办法是基于while来反复判断进入正常操作的临界条件是否满足：</strong></p>
<p>​    synchronized (obj) {<br>​            while (<condition does not hold>)<br>​                obj.wait();<br>​            … // Perform action appropriate to condition<br>​        } </condition></p>
<p>如何修复问题？</p>
<ol>
<li><p><strong>使用可同步的数据结构来存放数据，比如LinkedBlockingQueue之类。由这些同步的数据结构来完成繁琐的同步操作。</strong></p>
</li>
<li><p><strong>双层的synchronized使用没有意义，保留外层即可。</strong></p>
</li>
<li><p><strong>将if替换为while，解决虚假唤醒的问题</strong></p>
</li>
</ol>
<h5 id="（4）三个线程轮流打印1-100（一道常见的面试题）"><a href="#（4）三个线程轮流打印1-100（一道常见的面试题）" class="headerlink" title="（4）三个线程轮流打印1-100（一道常见的面试题）"></a>（4）三个线程轮流打印1-100（一道常见的面试题）</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WaitNoitfyDemo4</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;  <span class="comment">//三个线程轮流打印1-100</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        WaitNoitfyDemo4 waitNoitfyDemo4 = <span class="keyword">new</span> WaitNoitfyDemo4();</span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> Thread(waitNoitfyDemo4);</span><br><span class="line">        Thread thread2 = <span class="keyword">new</span> Thread(waitNoitfyDemo4);</span><br><span class="line">        Thread thread3 = <span class="keyword">new</span> Thread(waitNoitfyDemo4);</span><br><span class="line">        thread1.setName(<span class="string">"线程A"</span>);</span><br><span class="line">        thread2.setName(<span class="string">"线程B"</span>);</span><br><span class="line">        thread3.setName(<span class="string">"线程C"</span>);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">        thread3.start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="keyword">this</span>)&#123;</span><br><span class="line">                notify();       <span class="comment">//第一次的通知是无效的，因为此时等待池中没有线程</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">3000</span>); <span class="comment">//等待更能看出效果</span></span><br><span class="line">                &#125;<span class="keyword">catch</span> (InterruptedException e)&#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (i&lt;=<span class="number">100</span>)&#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()+<span class="string">":"</span>+i);</span><br><span class="line">                    i++;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        wait(); <span class="comment">//放弃锁，让给别人</span></span><br><span class="line">                    &#125;<span class="keyword">catch</span> (InterruptedException e)&#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="（5）-按照顺序去打印数字"><a href="#（5）-按照顺序去打印数字" class="headerlink" title="（5） 按照顺序去打印数字"></a>（5） 按照顺序去打印数字</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WaitNotifyDemo5</span> </span>&#123;  <span class="comment">//如果我们让三个线程按顺序去打印改怎么实现呢？比如线程1打印1，2，3线程2打印4，5，6依次类推。</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Printer</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">int</span> num = <span class="number">1</span>; <span class="comment">//开始数字</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> END = <span class="number">75</span>;</span><br><span class="line">        <span class="keyword">int</span> id;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Printer</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.id = id;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Printer.class) &#123;</span><br><span class="line">	<span class="comment">//注意第synchronized (Printer.class) ，为什么是Printer.class，而不是this呢？</span></span><br><span class="line">	<span class="comment">//是因为Print.class也是一个对象，在当前JVM中是唯一的类对象，它相当于一个“公证人”，三个线程竞争资源的时候都是从唯一的这个“公证人”手里拿到许可，才能进入synchronized体。</span></span><br><span class="line">	<span class="comment">//而如果是synchronized (this)的话，this也相当于一个“公证人”，那么三个线程各自有一个“公证人”，相当于各干各的，三个中间没有竞争关系，构不成同步。</span></span><br><span class="line">                <span class="keyword">while</span>(num &lt;= END)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(num / <span class="number">5</span> % <span class="number">3</span> == id)&#123; <span class="comment">//如果是属于自己的数，依次打印出来五个</span></span><br><span class="line">                        System.out.print(id + <span class="string">":"</span>);</span><br><span class="line">                        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)&#123;</span><br><span class="line">                            System.out.print(num++ + <span class="string">", "</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                        System.out.println();</span><br><span class="line">                        Printer.class.notifyAll();<span class="comment">//放弃CPU使用权，唤醒等待在Print.class队列上的的打印线程</span></span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            Printer.class.wait();<span class="comment">//如果不属于自己的数，把当前线程挂在Printer.class这个对象的等待队列上（也是放弃CPU使用权），等待唤醒</span></span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                            System.out.println(<span class="string">"id"</span> + <span class="string">"被打断了"</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//下面可以不按0，1，2的顺序来,而且在两两中间随便sleep()，都会正确打印出来</span></span><br><span class="line">        <span class="keyword">new</span> Thread( <span class="keyword">new</span> Printer(<span class="number">0</span>)).start();</span><br><span class="line">        <span class="keyword">new</span> Thread( <span class="keyword">new</span> Printer(<span class="number">1</span>)).start();</span><br><span class="line">        <span class="keyword">new</span> Thread( <span class="keyword">new</span> Printer(<span class="number">2</span>)).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="（6）一些值得去看的代码，下面给出一些链接"><a href="#（6）一些值得去看的代码，下面给出一些链接" class="headerlink" title="（6）一些值得去看的代码，下面给出一些链接"></a>（6）一些值得去看的代码，下面给出一些链接</h5><p><a href="http://cmsblogs.com/?p=1280" target="_blank" rel="noopener">http://cmsblogs.com/?p=1280</a></p>
<p><a href="https://blog.csdn.net/u010002184/article/details/72600694" target="_blank" rel="noopener">https://blog.csdn.net/u010002184/article/details/72600694</a></p>
<p><a href="https://blog.csdn.net/superit401/article/details/52254087" target="_blank" rel="noopener">https://blog.csdn.net/superit401/article/details/52254087</a></p>
<h4 id="五-存在的疑问与不足"><a href="#五-存在的疑问与不足" class="headerlink" title="五.存在的疑问与不足"></a>五.存在的疑问与不足</h4><ul>
<li><p>[ ] notify通知之后的线程还需要在锁池里面竞争吗？还是说之前内定好了？</p>
</li>
<li><p>[ ] 三个线程轮流打印1-100的代码中，第一个红线的上面三处，为什么线程A会切换到线程B，这三个输出是无序的嘛？</p>
</li>
<li><p>[x] B拿到锁了，进入sleep方法，让出cpu执行权，但是线程A没有对象锁，还是无法执行，线程B调用notify方法，但此时等待池没有等待的线程？——是的，等待池中没有，因为A和B在竞争的时候，B拿到了锁，A就会进入阻塞状态也就是被放进了锁池，并不在等待池。</p>
</li>
<li><p>[x] 释放锁的时机：wait之后就释放锁了还是等待sychronized执行完之后？——请看上面第二大点的第4小点</p>
</li>
<li><p>[x] wait 不能使用 if 为什么？？？存疑,到底会有什么问题？——看上面</p>
</li>
<li><p>[ ] 补充 wait与notify源码</p>
<p><a href="https://blog.csdn.net/lsgqjh/article/details/61915074&gt;" target="_blank" rel="noopener">https://blog.csdn.net/lsgqjh/article/details/61915074&gt;</a></p>
<p><a href="https://blog.csdn.net/boling_cavalry/article/details/77793224" target="_blank" rel="noopener">https://blog.csdn.net/boling_cavalry/article/details/77793224</a></p>
</li>
<li><p>[ ] 三. Object里面的finalize方法补充完全——只需要参考</p>
</li>
</ul>
<h4 id="六-参考资料"><a href="#六-参考资料" class="headerlink" title="六.参考资料"></a>六.参考资料</h4><p><a href="https://blog.csdn.net/u014561933/article/details/58639411" target="_blank" rel="noopener">https://blog.csdn.net/u014561933/article/details/58639411</a>             <a href="https://blog.csdn.net/u014561933/article/details/58639411" title="sleep()和wait()方法与对象锁、锁池" target="_blank" rel="noopener">我就是小在</a></p>
<p><a href="https://blog.csdn.net/qq_38182963/article/details/78948024" target="_blank" rel="noopener">https://blog.csdn.net/qq_38182963/article/details/78948024</a>       <a href="https://blog.csdn.net/qq_38182963/article/details/78948024" title="并发编程之 wait notify 方法剖析" target="_blank" rel="noopener">stateiso</a></p>
<p><a href="https://www.cnblogs.com/hy928302776/p/3255641.html" target="_blank" rel="noopener">https://www.cnblogs.com/hy928302776/p/3255641.html</a>             <a href="https://www.cnblogs.com/hy928302776/p/3255641.html" title="什么时候释放锁" target="_blank" rel="noopener">世界之大追梦者</a></p>
<p><a href="https://blog.csdn.net/lengxiao1993/article/details/52296220" target="_blank" rel="noopener">https://blog.csdn.net/lengxiao1993/article/details/52296220</a>       <a href="https://blog.csdn.net/lengxiao1993/article/details/52296220" title=" 搭配synchonized关键字使用" target="_blank" rel="noopener">萧萧冷</a></p>
<p><a href="https://blog.csdn.net/perrywork/article/details/16819153" target="_blank" rel="noopener">https://blog.csdn.net/perrywork/article/details/16819153</a>         <a href="https://blog.csdn.net/perrywork/article/details/16819153" title="3个线程依次轮流打印出75个数" target="_blank" rel="noopener">zhao_perry</a></p>
<p><a href="https://www.linuxidc.com/Linux/2014-03/98715.htm" target="_blank" rel="noopener">https://www.linuxidc.com/Linux/2014-03/98715.htm</a>              <a href="https://www.linuxidc.com/Linux/2014-03/98715.htm" title="一道阿里面试题的分析与应对" target="_blank" rel="noopener">blueheart20</a></p>
<p><a href="https://blog.csdn.net/yiifaa/article/details/76341707" target="_blank" rel="noopener">https://blog.csdn.net/yiifaa/article/details/76341707</a>               <a href="https://blog.csdn.net/yiifaa/article/details/76341707" title="为什么wait()一定要放在循环中" target="_blank" rel="noopener">蚁方阵</a></p>
<p><a href="https://blog.csdn.net/qq_35181209/article/details/77362297" target="_blank" rel="noopener">https://blog.csdn.net/qq_35181209/article/details/77362297</a>        <a href="https://blog.csdn.net/qq_35181209/article/details/77362297" title="wait放在while循环里面的原因探析" target="_blank" rel="noopener">菜鸡小王子</a></p>
</the></excerpt>
      
      
    </div>
    
  </div>
  
    
    <div class="copyright">
        <p><span>本文标题:</span><a href="/2019/03/15/Object源码剖析/">Object源码剖析（顺带分析了notify/wait）</a></p>
        <p><span>文章作者:</span><a href="/" title="访问 Whits 的个人博客">Whits</a></p>
        <p><span>发布时间:</span>2019年03月15日 - 08时00分</p>
        <p><span>最后更新:</span>2019年05月07日 - 20时33分</p>
        <p>
            <span>原始链接:</span><a class="post-url" href="/2019/03/15/Object源码剖析/" title="Object源码剖析（顺带分析了notify/wait）">http://yoursite.com/2019/03/15/Object源码剖析/</a>
            <span class="copy-path" data-clipboard-text="原文: http://yoursite.com/2019/03/15/Object源码剖析/　　作者: Whits" title="点击复制文章链接"><i class="fa fa-clipboard"></i></span>
            <script src="/js/clipboard.min.js"></script>
            <script> var clipboard = new Clipboard('.copy-path'); </script>
        </p>
        <p>
            <span>许可协议:</span><i class="fa fa-creative-commons"></i> <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/3.0/cn/" title="中国大陆 (CC BY-NC-SA 3.0 CN)" target="_blank">"署名-非商用-相同方式共享 3.0"</a> 转载请保留原文链接及作者。
        </p>
    </div>



<nav id="article-nav">
  
    <a href="/2019/03/23/String源码剖析/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption"><</strong>
      <div class="article-nav-title">
        
          String部分源码剖析
        
      </div>
    </a>
  
  
</nav>

  
</article>

    <div id="toc" class="toc-article">
    <strong class="toc-title">文章目录</strong>
    <ol class="toc"><li class="toc-item toc-level-4"><a class="toc-link" href="#一-等待-唤醒机制的常见用法"><span class="toc-number">1.</span> <span class="toc-text">一. 等待/唤醒机制的常见用法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#二-Object里面的wait与notify方法"><span class="toc-number">2.</span> <span class="toc-text">二. Object里面的wait与notify方法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-监视器，对象锁，锁池与等待池"><span class="toc-number">2.1.</span> <span class="toc-text">(1).监视器，对象锁，锁池与等待池</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-注意事项"><span class="toc-number">2.2.</span> <span class="toc-text">(2).注意事项</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-工作流程"><span class="toc-number">2.3.</span> <span class="toc-text">(3).工作流程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-什么时候释放对象锁？"><span class="toc-number">2.4.</span> <span class="toc-text">(4).什么时候释放对象锁？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-在synchronized中才能使用wait与notify方法"><span class="toc-number">2.5.</span> <span class="toc-text">(5).在synchronized中才能使用wait与notify方法?</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6-如何正确地使用唤醒等待机制？——-effective-java"><span class="toc-number">2.6.</span> <span class="toc-text">(6).如何正确地使用唤醒等待机制？—— effective java</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#7-为什么一定要while判断，不能用if"><span class="toc-number">2.7.</span> <span class="toc-text">(7).为什么一定要while判断，不能用if</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#8-notify-和-notifyAll-的一段代码分析"><span class="toc-number">2.8.</span> <span class="toc-text">(8).notify 和 notifyAll 的一段代码分析</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#9-延伸出来的生产者与消费者问题"><span class="toc-number">2.9.</span> <span class="toc-text">(9).延伸出来的生产者与消费者问题</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#三-Object里面的finalize方法"><span class="toc-number">3.</span> <span class="toc-text">三. Object里面的finalize方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#四-参考代码"><span class="toc-number">4.</span> <span class="toc-text">四. 参考代码</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#（1）线程相互通信，这是一个有缺点的案例，使用wait前，最好需要加上while循环"><span class="toc-number">4.1.</span> <span class="toc-text">（1）线程相互通信，这是一个有缺点的案例，使用wait前，最好需要加上while循环</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#（2）notify使用不当造成死锁"><span class="toc-number">4.2.</span> <span class="toc-text">（2）notify使用不当造成死锁</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#（3）虚假唤醒（原文章已经过修改-参考链接见下方）"><span class="toc-number">4.3.</span> <span class="toc-text">（3）虚假唤醒（原文章已经过修改,参考链接见下方）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#（4）三个线程轮流打印1-100（一道常见的面试题）"><span class="toc-number">4.4.</span> <span class="toc-text">（4）三个线程轮流打印1-100（一道常见的面试题）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#（5）-按照顺序去打印数字"><span class="toc-number">4.5.</span> <span class="toc-text">（5） 按照顺序去打印数字</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#（6）一些值得去看的代码，下面给出一些链接"><span class="toc-number">4.6.</span> <span class="toc-text">（6）一些值得去看的代码，下面给出一些链接</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#五-存在的疑问与不足"><span class="toc-number">5.</span> <span class="toc-text">五.存在的疑问与不足</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#六-参考资料"><span class="toc-number">6.</span> <span class="toc-text">六.参考资料</span></a></li></ol>
</div>
<input type="button" id="tocButton" value="隐藏目录" title="点击按钮隐藏或者显示文章目录">

<script src="https://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js"></script>
<script>
    var valueHide = "隐藏目录";
    var valueShow = "显示目录";

    if ($(".left-col").is(":hidden")) {
        $("#tocButton").attr("value", valueShow);
    }
    $("#tocButton").click(function() {
        if ($("#toc").is(":hidden")) {
            $("#tocButton").attr("value", valueHide);
            $("#toc").slideDown(320);
        }
        else {
            $("#tocButton").attr("value", valueShow);
            $("#toc").slideUp(350);
        }
    })
    if ($(".toc").length < 1) {
        $("#toc, #tocButton").hide();
    }
</script>





<div class="bdsharebuttonbox">
	<a href="#" class="fx fa-weibo bds_tsina" data-cmd="tsina" title="分享到新浪微博"></a>
	<a href="#" class="fx fa-weixin bds_weixin" data-cmd="weixin" title="分享到微信"></a>
	<a href="#" class="fx fa-qq bds_sqq" data-cmd="sqq" title="分享到QQ好友"></a>
	<a href="#" class="fx fa-facebook-official bds_fbook" data-cmd="fbook" title="分享到Facebook"></a>
	<a href="#" class="fx fa-twitter bds_twi" data-cmd="twi" title="分享到Twitter"></a>
	<a href="#" class="fx fa-linkedin bds_linkedin" data-cmd="linkedin" title="分享到linkedin"></a>
	<a href="#" class="fx fa-files-o bds_copy" data-cmd="copy" title="分享到复制网址"></a>
</div>
<script>window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"2","bdMiniList":false,"bdPic":"","bdStyle":"2","bdSize":"24"},"share":{}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];</script>




    
        <div id="gitments"></div>
<script src="/js/gitment.browser.js"></script>
<script>
    var gitment = new Gitment({
      id: window.location.pathname,
      owner: 'luuman',
      repo: 'luuman.github.io',
      oauth: {
        client_id: '',
        client_secret: '',
      },
    })
    gitment.render('gitments')
</script>
    



    <div class="scroll" id="post-nav-button">
        
            <a href="/2019/03/23/String源码剖析/" title="上一篇: String部分源码剖析">
                <i class="fa fa-angle-left"></i>
            </a>
        
        <a title="文章列表"><i class="fa fa-bars"></i><i class="fa fa-times"></i></a>
        
            <a href="/" title="回到主页"><i class="fa fa-home"></i></a>
        
    </div>
    <ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2019/04/14/Java运行期优化(二)/">Java晚期(运行期)优化(二)</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/04/14/Java运行期优化(一)/">Java晚期(运行期)优化(一)</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/04/06/Java编译期优化/">Java早期(编译期)优化</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/03/23/String源码剖析/">String部分源码剖析</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/03/15/Object源码剖析/">Object源码剖析（顺带分析了notify/wait）</a></li></ul>
    <script src="https://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js"></script>
    <script>
        $(".post-list").addClass("toc-article");
        $(".post-list-item a").attr("target","_blank");
        $("#post-nav-button > a:nth-child(2)").click(function() {
            $(".fa-bars, .fa-times").toggle();
            $(".post-list").toggle(300);
            if ($(".toc").length > 0) {
                $("#toc, #tocButton").toggle(200, function() {
                    if ($(".switch-area").is(":visible")) {
                        $("#tocButton").attr("value", valueHide);
                        }
                    })
            }
            else {
            }
        })
    </script>



    <script>
        
    </script>
</div>
      <footer id="footer">
    <div class="outer">
        <div id="footer-info">
            <div class="footer-left">
                &copy; 2019 Whits
            </div>
            <div class="footer-right">
                <a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/luuman/hexo-theme-spfk" target="_blank">spfk</a> by luuman
            </div>
        </div>
        
            <div class="visit">
                
                    <span id="busuanzi_container_site_pv" style="display:none">
                        <span id="site-visit">到访数: 
                            <span id="busuanzi_value_site_uv"></span>
                        </span>
                    </span>
                
                
                    <span>, </span>
                
                
                    <span id="busuanzi_container_page_pv" style="display:none">
                        <span id="page-visit">本页阅读量: 
                            <span id="busuanzi_value_page_pv"></span>
                        </span>
                    </span>
                
            </div>
        
    </div>
</footer>

    </div>
    <script src="https://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js"></script>
<script src="/js/main.js"></script>

    <script>
        $(document).ready(function() {
            var backgroundnum = 24;
            var backgroundimg = "url(/background/bg-x.jpg)".replace(/x/gi, Math.ceil(Math.random() * backgroundnum));
            $("#mobile-nav").css({"background-image": backgroundimg,"background-size": "cover","background-position": "center"});
            $(".left-col").css({"background-image": backgroundimg,"background-size": "cover","background-position": "center"});
        })
    </script>





<div class="scroll" id="scroll">
    <a href="#"><i class="fa fa-arrow-up"></i></a>
    <a href="#comments"><i class="fa fa-comments-o"></i></a>
    <a href="#footer"><i class="fa fa-arrow-down"></i></a>
</div>
<script>
    $(document).ready(function() {
        if ($("#comments").length < 1) {
            $("#scroll > a:nth-child(2)").hide();
        };
    })
</script>

<script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
</script>

  <script language="javascript">
    $(function() {
        $("a[title]").each(function() {
            var a = $(this);
            var title = a.attr('title');
            if (title == undefined || title == "") return;
            a.data('title', title).removeAttr('title').hover(

            function() {
                var offset = a.offset();
                $("<div id=\"anchortitlecontainer\"></div>").appendTo($("body")).html(title).css({
                    top: offset.top - a.outerHeight() - 15,
                    left: offset.left + a.outerWidth()/2 + 1
                }).fadeIn(function() {
                    var pop = $(this);
                    setTimeout(function() {
                        pop.remove();
                    }, pop.text().length * 800);
                });
            }, function() {
                $("#anchortitlecontainer").remove();
            });
        });
    });
</script>


  </div>
</body>
</html>